<!doctype html>
<html lang="en">
  <head>
  <title>Stardog 2.2.2 Docs: OWL & Rule Reasoning</title>
  <script src="/js/libs/modernizr-2.6.2.min.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-Powered-By" content="DocPad v6.44.0">
  <link rel="stylesheet" href="/css/gumby.css">
  <!--     //a block for ipad, etc... might should go in meta -->
  </head>

<body>
<!--
  <div class="" id="the-content">
    <div class="wrapper shaded" id="topblock">
    <div class="row">
      <div class="four columns">
        <a href="/"><img class="resrc" src="http://app.resrc.it/S=H55/R=L/http://docs.stardog.com/img/logotype.png"/></a>
      </div>
      <div class="eight columns">
        
      </div>
    </div>
  </div>
-->
<div id="page-wrap">
 <div id="the-content">
  <div id="theborder" class="wrapper">
    <!-- full bleed top border styling.... -->
      <div class="twelve columns"></div>
  </div>

    <div class="row">
        <div class="four columns stretch-container" id="sidebar1">
          <nav id="sidebar-nav-holder" class="fixed vertical-nav stretch-y" gumby-fixed="top">
            <div id="sidebar-logo">
              <a id="a52" style="text-decoration: none; background-color: none; border: none; color: none;" href="http://stardog.com/">
                <img id="thelogo" src="http://docs.stardog.com/img/sd.png">       
              </a>
            </div>
            
              <!-- 
	<h3 id="tochead">Reasoning Contents</h3>
 -->

<ul class="sidebar-nav">
    
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Introduction" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Introduction">
            <strong>Introduction</strong>
        </a>
        <!-- <li><a href="#sd-Introduction" class="skiplink">Introduction</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Using-Reasoning" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Using-Reasoning">
            <strong>Using Reasoning</strong>
        </a>
        <!-- <li><a href="#sd-Using-Reasoning" class="skiplink">Using Reasoning</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Explaining-Reasoning-Results" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Explaining-Reasoning-Results">
            <strong>Explaining Reasoning Results</strong>
        </a>
        <!-- <li><a href="#sd-Explaining-Reasoning-Results" class="skiplink">Explaining Reasoning Results</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-User-defined-Rule-Reasoning" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-User-defined-Rule-Reasoning">
            <strong>User-defined Rule Reasoning</strong>
        </a>
        <!-- <li><a href="#sd-User-defined-Rule-Reasoning" class="skiplink">User-defined Rule Reasoning</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Special-Predicates" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Special-Predicates">
            <strong>Special Predicates</strong>
        </a>
        <!-- <li><a href="#sd-Special-Predicates" class="skiplink">Special Predicates</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Query-Rewriting" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Query-Rewriting">
            <strong>Query Rewriting</strong>
        </a>
        <!-- <li><a href="#sd-Query-Rewriting" class="skiplink">Query Rewriting</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Performance-Hints" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Performance-Hints">
            <strong>Performance Hints</strong>
        </a>
        <!-- <li><a href="#sd-Performance-Hints" class="skiplink">Performance Hints</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Not-Seeing-Expected-Results-" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Not-Seeing-Expected-Results-">
            <strong>Not Seeing Expected Results?</strong>
        </a>
        <!-- <li><a href="#sd-Not-Seeing-Expected-Results-" class="skiplink">Not Seeing Expected Results?</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Known-Issues" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Known-Issues">
            <strong>Known Issues</strong>
        </a>
        <!-- <li><a href="#sd-Known-Issues" class="skiplink">Known Issues</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    
    <!-- [data-target='-->
        <li>
            <a href="#sd-Terminology" class="skip" gumby-easing="easeOutQuad" gumby-duration="300" gumby-goto="#sd-Terminology">
            <strong>Terminology</strong>
        </a>
        <!-- <li><a href="#sd-Terminology" class="skiplink">Terminology</a> -->
            
                <ul class="sidebar-nav">
                
    

                </ul>
            
        </li>
    

</ul>
              <p id="tocnav">
              
                <a class="iconlinks" href="/"><i style="padding-left:0px; margin-left:0px;" class="icon-home iconlinks"></i></a>&nbsp;
              
              <a href="#" id="" class="skip iconlinks" gumby-easing="easeInOutQuad" gumby-goto="top" gumby-duration="2000">
                <i style="padding-left:0px; margin-left:0px;" class="icon-publish iconlinks"></i>
              </a> &nbsp;
              <a href="https://twitter.com/stardog_db" class="iconlinks">
                <i style="padding-left:0px; margin-left:0px;" class="icon-twitter iconlinks"></i>
              </a>
              </p>
            
          </nav>
        </div>

        <div class="eight columns">
          <!-- woof! -->
            <div class="row">
              <p id="quote"><em><strong>The proof of a system's value is its existence.</strong></em>&mdash;Alan Perlis, <cite>Epigrams in Programming</cite></p>
              <div class="pull_left"><h1 id="title-subhead">OWL & Rule Reasoning</h1></div>
            </div>
          <!-- summary -->
          
          <div id="mdblock">
            <h2 id="sd-Introduction">Introduction</h2>
<p>In this chapter we describe <a href="#reasoning">how to use Stardog's reasoning
capabilities</a>; we also address some <a href="#trouble">common
problems</a> and <a href="#issues">known issues</a>. We also describe
<a href="#approach">Stardog's approach to query answering</a> in some detail, as
well as a set of <a href="#guidelines">guidelines</a> that contribute to efficient
query answering. If you are not familiar with the terminology, you can
peruse the section on <a href="#terminology">terminology</a>.</p>
<p>Stardog reasoning is based on the <a href="http://www.w3.org/TR/2010/WD-sparql11-entailment-20100126/#id45013">OWL 2 Direct Semantics Entailment
Regime</a>.
Stardog performs reasoning in a lazy and late-binding fashion: it
does not materialize inferences; but, rather, reasoning is performed at
query time according to a given reasoning level. This allows for maximum
flexibility while maintaining excellent performance and scalability.</p>
<h3>Reasoning Levels</h3>
<p>Stardog supports several reasoning levels; the reasoning level determines the kinds of inference rules or axioms that are to be considered during query evaluation:</p>
<ul>
<li><strong>NONE</strong>. No axioms are considered.</li>
<li><strong>RDFS</strong>. For the OWL 2 axioms allowed in <a href="http://www.w3.org/TR/rdf-schema/">RDF
schema</a> (mainly subclasses,
subproperties, domain, and ranges).</li>
<li><strong>QL</strong>. For <a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_QL">OWL 2 QL</a>
axioms.</li>
<li><strong>RL</strong>. For <a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_RL">OWL 2 RL</a>
axioms.</li>
<li><strong>EL</strong>. For <a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_EL">OWL 2 EL</a>
axioms.</li>
<li><strong>DL</strong>. For <a href="http://www.w3.org/TR/owl2-syntax/">OWL 2 DL</a> axioms.</li>
<li><strong>SL</strong>. For a combination of RDFS, QL, RL, and EL axioms, plus <a href="http://www.w3.org/Submission/SWRL/">SWRL rules</a>.</li>
</ul>
<h2 id="sd-Using-Reasoning">Using Reasoning</h2>
<p>In order to perform query evaluation with reasoning, Stardog requires a
schema (sometimes called a “TBox”) to be present in the database. Since
schemas are serialized as RDF, they are loaded into a Stardog database
in the same way that any RDF is loaded into a Stardog database. Also,
note that, since it is just more RDF triples, the schema may change as
needed: it is neither fixed nor compiled in any special way.</p>
<p>The schema may reside in the default graph, in a specific named graph,
or in a collection of graphs. You can tell Stardog where the schema is
by setting the <code>reasoning.schema.graphs</code> property to one or more named
graph URIs. If you want the default graph to be considered part of the
schema, then you can use the special built-in URI
<code>tag:stardog:api:context:default</code>. If you want to use all named graphs
(that is, to tell Stardog to look for the schema in every named graph),
you can use <code>tag:stardog:api:context:all</code>. The default value for this
property is to use the default graph only.</p>
<h3>Query Answering</h3>
<p>All of Stardog's interfaces (API, network, and CLI) support reasoning during query evaluation.</p>
<h3>Command Line</h3>
<p>In order to evaluate queries in Stardog using reasoning via the command
line, a specific reasoning level must be specified in the <a href="../admin/">connection
string</a>:</p>
<pre class="highlighted"><code class="bash">$ ./stardog query <span class="string">"myDB;reasoning=QL"</span> <span class="string">"SELECT ?s { ?s a :C } LIMIT 10"</span></code></pre>
<h3>HTTP</h3>
<p>For HTTP, the reasoning level is specified with the other HTTP request
parameters:</p>
<pre class="highlighted"><code class="bash">$ curl -u admin:admin -X GET <span class="string">"http://localhost:5822/myDB/query?reasoning=ql&amp;query=..."</span></code></pre>
<h3><code>ReasoningConnection</code> API</h3>
<p>In order to use the ReasoningConnection API one needs to specify a
reasoning level. See the <a href="../java/">Java Programming</a> chapter for
details on specifying the reasoning level programmatically.</p>
<p>Currently, the API has two methods:</p>
<ul>
<li><code>isConsistent()</code>, which can be used to check if the current DB is
consistent with respect to the reasoning level.</li>
<li><code>isSatisfiable(URI theURIClass)</code>, which can be used to check if the
given class if satisfiable with respect to the current DB and
reasoning level.</li>
</ul>
<h2 id="sd-Explaining-Reasoning-Results">Explaining Reasoning Results</h2>
<p>Stardog can be used to check if the current DB logically entails a set
of triples; moreover, Stardog can explain why this is so. An explanation
of an inference is the minimum set of statements explicitly stored in
the database that together justify or warrant the inference.
Explanations are useful for debugging and understanding, especially when
large number of statements interact with each other to infer new
statements.</p>
<p>Explanations can be retrieved using the CLI command <code>explain inference</code>
by providing an input file that contains the inferences to be explained:</p>
<pre class="highlighted"><code class="bash">$ stardog reasoning explain <span class="string">"myDB;reasoning=EL"</span> inference_to_explain.ttl</code></pre>
<p>The output is displayed in a concise syntax designed to be legible; but
it can be rendered in any one of the supported RDF syntaxes if desired.
Explanations are also accessible through the <a href="../network/#extended-http">extended HTTP
protocol</a> and SNARL API. See the examples
included in the distribution for more details about retrieving
explanations programmatically.</p>
<p><div id="sd-Proof-Trees"></div></p>
<h3>Proof Trees </h3>
<p>Proof trees are a hierarchical presentation of multiple explanations (of inferences) to make data, schemas, and rules more intelligible. Proof tree<a id="fn-ref-1" href="#footnote-1" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-1"><sup>1</sup></a> provides an explanation for an inference or an
inconsistency in a <em>hierarchical structure</em>. Nodes in the proof tree may
represent an assertion in a Stardog database. Multiple assertion nodes are
grouped under an inferred node.</p>
<h4>Example</h4>
<p>For example, if we are explaining the inferred triple <code>:Alice
rdf:type :Employee</code> , the root of the proof tree will show that
inference:</p>
<pre class="highlighted"><code class="sparql">INFERRED <span class="uri">:Alice</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span></code></pre>
<p>The children of an inferred node will provide more explanation for
that inference:</p>
<pre class="highlighted"><code class="sparql">INFERRED <span class="uri">:Alice</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span>
    ASSERTED <span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
    INFERRED <span class="uri">:Alice</span> <span class="uri">rdf:type</span> <span class="uri">:Manager</span></code></pre>
<p>The fully expanded proof tree will show the asserted triples and
axioms for every inference:</p>
<pre class="highlighted"><code class="sparql">INFERRED <span class="uri">:Alice</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span>
    ASSERTED <span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
    INFERRED <span class="uri">:Alice</span> <span class="uri">rdf:type</span> <span class="uri">:Manager</span>
        ASSERTED <span class="uri">:Alice</span> <span class="uri">:supervises</span> <span class="uri">:Bob</span>
        ASSERTED <span class="uri">:supervises</span> <span class="uri">rdfs:domain</span> <span class="uri">:Manager</span></code></pre>
<p>The CLI explanation command prints the proof tree using indented text;
but, using the SNARL API, it is easy to create a tree widget
in a GUI to show the explanation tree, such that users can expand and
collapse details in the explanation.</p>
<p>Another feature of proof trees is the ability to merge multiple
explanations into a single proof tree with multiple branches when
explanations have common statements. Consider the following example
database:</p>
<pre class="highlighted"><code class="sparql"><span class="comment">#schema
</span><span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:ProjectManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
<span class="uri">:ProjectManager</span> <span class="uri">owl:equivalentClass</span> (<span class="uri">:manages</span> some <span class="uri">:Project</span>)
<span class="uri">:supervises</span> <span class="uri">rdfs:domain</span> <span class="uri">:Manager</span>
<span class="uri">:ResearchProject</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Project</span>
<span class="uri">:projectID</span> <span class="uri">rdfs:domain</span> <span class="uri">:Project</span>

<span class="comment"># instance data
</span><span class="uri">:Alice</span> <span class="uri">:supervises</span> <span class="uri">:Bob</span>
<span class="uri">:Alice</span> <span class="uri">:manages</span> <span class="uri">:ProjectX</span>
<span class="uri">:ProjectX</span> <span class="uri">a</span> <span class="uri">:ResearchProject</span>
<span class="uri">:ProjectX</span> <span class="uri">:projectID</span> <span class="string">"123-45-6789"</span></code></pre>
<p>In this database, there are three different unique explanations
for the inference <code>:Alice rdf:type :Employee</code>:</p>
<h5>Explanation 1</h5>
<pre class="highlighted"><code class="sparql"><span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:ProjectManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
<span class="uri">:supervises</span> <span class="uri">rdfs:domain</span> <span class="uri">:Manager</span>
<span class="uri">:Alice</span> <span class="uri">:supervises</span> <span class="uri">:Bob</span></code></pre>
<h5>Explanation 2</h5>
<pre class="highlighted"><code class="sparql"><span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:ProjectManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
<span class="uri">:ProjectManager</span> <span class="uri">owl:equivalentClass</span> (<span class="uri">:manages</span> some <span class="uri">:Project</span>)
<span class="uri">:ResearchProject</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Project</span>
<span class="uri">:Alice</span> <span class="uri">:manages</span> <span class="uri">:ProjectX</span>
<span class="uri">:ProjectX</span> <span class="uri">a</span> <span class="uri">:ResearchProject</span></code></pre>
<h5>Explanation 3</h5>
<pre class="highlighted"><code class="sparql"><span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:ProjectManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
<span class="uri">:ProjectManager</span> <span class="uri">owl:equivalentClass</span> (<span class="uri">:manages</span> some <span class="uri">:Project</span>)
<span class="uri">:projectID</span> <span class="uri">rdfs:domain</span> <span class="uri">:Project</span>
<span class="uri">:Alice</span> <span class="uri">:manages</span> <span class="uri">:ProjectX</span>
<span class="uri">:ProjectX</span> <span class="uri">:projectID</span> <span class="string">"123-45-6789"</span></code></pre>
<p>All three explanations have some triples in common; but
when explanations are retrieved separately, it is hard to see how
these explanations are related. When explanations are merged, we
get a single proof tree where alternatives for subtrees of the
proof are shown inline. In indented text rendering, the merged
tree for the above explanations would look as follows:</p>
<pre class="highlighted"><code class="sparql">INFERRED <span class="uri">:Alice</span> <span class="uri">a</span> <span class="uri">:Employee</span>
   ASSERTED <span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
   <span class="number">1.1</span>) INFERRED <span class="uri">:Alice</span> <span class="uri">a</span> <span class="uri">:Manager</span>
      ASSERTED <span class="uri">:supervises</span> <span class="uri">rdfs:domain</span> <span class="uri">:Manager</span>
      ASSERTED <span class="uri">:Alice</span> <span class="uri">:supervises</span> <span class="uri">:Bob</span>
   <span class="number">1.2</span>) INFERRED <span class="uri">:Alice</span> <span class="uri">a</span> <span class="uri">:Manager</span>
      ASSERTED <span class="uri">:ProjectManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
      INFERRED <span class="uri">:Alice</span> <span class="uri">a</span> <span class="uri">:ProjectManager</span>
         ASSERTED <span class="uri">:ProjectManager</span> <span class="uri">owl:equivalentClass</span> (<span class="uri">:manages</span> some <span class="uri">:Project</span>)
         ASSERTED <span class="uri">:Alice</span> <span class="uri">:manages</span> <span class="uri">:ProjectX</span>
         <span class="number">2.1</span>) INFERRED <span class="uri">:ProjectX</span> <span class="uri">a</span> <span class="uri">:Project</span>
            ASSERTED <span class="uri">:projectID</span> <span class="uri">rdfs:domain</span> <span class="uri">:Project</span>
            ASSERTED <span class="uri">:ProjectX</span> <span class="uri">:projectID</span> <span class="string">"123-45-6789"</span>
         <span class="number">2.2</span>) INFERRED <span class="uri">:ProjectX</span> <span class="uri">a</span> <span class="uri">:Project</span>
            ASSERTED <span class="uri">:ResearchProject</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Project</span>
            ASSERTED <span class="uri">:ProjectX</span> <span class="uri">a</span> <span class="uri">:ResearchProject</span></code></pre>
<p>In the merged proof tree, alternatives for an
explanation is shown with a number id. In the above tree,
<code>:Alice a :Manager</code> is the first inference for which we have
multiple explanations so it gets the id <code>1</code>. Then each alternative
explanation gets an id appended to this (so explanations <code>1.1</code> and
<code>1.2</code> are both alternative explanations for inference <code>1</code>). We
also have multiple explanations for inference <code>:ProjectX a :Project</code>
so its alternatives get ids <code>2.1</code> and <code>2.2</code>.
Again, a tree widget in a GUI can show this proof tree in a more
user-friendly way.</p>
<h2 id="sd-User-defined-Rule-Reasoning">User-defined Rule Reasoning</h2>
<p>Many reasoning problems may be solved with OWL‘s axiom-based approach;
but, of course, not all reasoning problems are amenable to this
approach. A user-defined rules approach complements the OWL axiom-based
approach nicely and increases the expressive power of a reasoning system
from the user’s point of view. Many RDF databases support user-defined
rules only. Stardog is one of the only RDF databases that
comprehensively supports both axioms and rules. Some problems (and some
people) are simply a better fit for a rules-based approach to modeling
and reasoning than to an axioms-based approach.</p>
<p><strong>Remember</strong>: there isn‘t a one-size-fits-all answer to the question
“rules or axioms or both?” Use the thing that makes the most sense to you
and to the people you’re working with, etc.</p>
<p>Stardog supports user-defined rule reasoning together with a rich set of
built-in functions using the <a href="http://www.w3.org/Submission/SWRL/">SWRL</a>
syntax and builtin-ins library. In order to apply SWRL user-defined
rules, you must include the rules as part of the database's schema: that
is, put your rules where your axioms are, i.e., in the schema. See
<a href="#tbox_extraction">Schema Extraction</a> for more details. Once the rules
are part of the schema, they will be used for reasoning automatically
when using the <strong>SL</strong> reasoning level.</p>
<p>Assertions implied by the rules <em>will not</em> be materialized. Instead,
rules are used to expand queries just as regular axioms are in Stardog.
<strong>Note</strong>: to trigger rules to “fire”, execute a query. It's that simple.</p>
<p><div id="sd-Stardog-Rules-Syntax"></div></p>
<h3>Stardog Rules Syntax </h3>
<p>Stardog supports two different syntaxes for defining rules. The first
is native Stardog Rules syntax and is based on SPARQL, so you
can re-use what you already know about SPARQL to write rules.
<strong>Unless you have specific requirements otherwise, you should use this
syntax for user-defined rules in Stardog.</strong> The second, the <em>de facto</em>
standard RDF/XML syntax for SWRL. It has the advantage of being supported
in many tools; but it‘s not fun to read or to write. You probably
don’t want to use it. Better: don't use this syntax!</p>
<p>Stardog Rules Syntax is basically SPARQL “basic graph patterns” (BGPs) plus some
very explicit new bits (<code>IF-THEN</code>) to denote the head and the body of a
rule.<a id="fn-ref-2" href="#footnote-2" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-2"><sup>2</sup></a> You define URI prefixes in the normal way  (examples below) and use
regular SPARQL variables for rule variables. As you can see, some SPARQL 1.1
syntactic sugar—property paths, especially, but also bnode syntax—make complex
Stardog Rules quite concise and elegant.</p>
<h4>How to Use Stardog Rules</h4>
<p>There are three things to sort out:</p>
<ol>
<li>Where to put these rules?</li>
<li>How to represent these rules?</li>
<li>What are the gotchas?</li>
</ol>
<p>First, the rules go into the database, of course; and, in particular, they go into
the named graph in which Stardog expects to find the TBox. This setting by
default in Stardog is the “default graph”, i.e., unless you've changed
the value of <code>reasoning.schema.graphs</code>, you're probably going to be
fine; that is, just add the rules to the database and it will all
work out.<a id="fn-ref-3" href="#footnote-3" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-3"><sup>3</sup></a></p>
<p>Second, you represent the rules with specially constructed RDF triples. Here's
a kind of template example:</p>
<pre class="highlighted"><code class="sparql">@<span class="keyword">prefix</span> rule: <span class="uri">&lt;tag:stardog:api:rule:&gt;</span> .
[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span>;
   <span class="uri">rule:content</span> <span class="string">"""
   ...la di dah the rule goes here!
   """</span>.</code></pre>
<p>So there's a namespace—<code>tag:stardog:api:rule:</code>—that has a predicate, <code>content</code>, and a class, <code>SPARQLRule</code>. The object of this triple contains <em>one</em> rule in Stardog Rules syntax. A more realistic example:</p>
<pre class="highlighted"><code class="sparql">@<span class="keyword">prefix</span> rule: <span class="uri">&lt;tag:stardog:api:rule:&gt;</span> .

[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
  <span class="uri">rule:content</span> <span class="string">"""
    PREFIX :&lt;urn:test:&gt;
      <span class="rule"><span class="keyword">IF</span> </span>{
            ?r a :Rectangle ;
               :width ?w ;
               :height ?h
            BIND (?w * ?h AS ?area)
          }
      <span class="rule"><span class="keyword">THEN</span> </span>{
              ?r :area ?area
          }"""</span> .</code></pre>
<p>That's pretty easy!<a id="fn-ref-4" href="#footnote-4" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-4"><sup>4</sup></a></p>
<p>Third, what are the gotchas? There are two:</p>
<ol>
<li>The RDF serialization of rules in, say, a Turtle file has to use the <code>tag:stardog:api:rule:</code> namespace URI and then whatever prefix, if any, mechanism that's valid for that serialization. In the examples here, we use Turtle. Hence, we use <code>@prefix</code>, etc.</li>
<li>However, the namespace URIs used <em>by the rules themselves</em> can be defined in only two places: the string that contains the rule—in the example above, you can see the default namespace is <code>urn:test:</code>—or in the Stardog database in which the rules are stored. Either place will work; if there are conflicts, the “closest definition wins”, that is, if <code>foo:Example</code> is defined in both the rule content and in the Stardog database, the definition in the rule content is the one that Stardog will use.</li>
</ol>
<h4>Stardog Rules Examples</h4>
<pre class="highlighted"><code class="sparql"><span class="keyword">PREFIX</span> rule: <span class="uri">&lt;tag:stardog:api:rule:&gt;</span>
<span class="keyword">PREFIX</span> : <span class="uri">&lt;urn:test:&gt;</span>
<span class="keyword">PREFIX</span> gr: <span class="uri">&lt;http://purl.org/goodrelations/v1#&gt;</span>

<span class="uri">:Product1</span> <span class="uri">gr:hasPriceSpecification</span> [ <span class="uri">gr:hasCurrencyValue</span> <span class="number">100.0</span> ] .
<span class="uri">:Product2</span> <span class="uri">gr:hasPriceSpecification</span> [ <span class="uri">gr:hasCurrencyValue</span> <span class="number">500.0</span> ] .
<span class="uri">:Product3</span> <span class="uri">gr:hasPriceSpecification</span> [ <span class="uri">gr:hasCurrencyValue</span> <span class="number">2000.0</span> ] .

[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
   <span class="uri">rule:content</span> <span class="string">"""
       PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
       PREFIX gr: &lt;http://purl.org/goodrelations/v1#&gt;
       PREFIX :&lt;urn:test:&gt;
     <span class="rule"><span class="keyword">IF</span> </span>{
        ?offering gr:hasPriceSpecification ?ps .
        ?ps gr:hasCurrencyValue ?price .
        FILTER (?price &gt;= 200.00).
     }
     <span class="rule"><span class="keyword">THEN</span> </span>{
        ?offering a :ExpensiveProduct .
     }
   """</span>.</code></pre>
<p>This example is self-contained: it contains some data (the <code>:Product...</code> triples) and a rule. It also demonstrates the use of SPARQL's <code>FILTER</code> to do numerical (and other) comparisons.</p>
<p>Here's a more complex example that includes four rules and, again, some data.</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">PREFIX</span> rule: <span class="uri">&lt;tag:stardog:api:rule:&gt;</span>
<span class="keyword">PREFIX</span> : <span class="uri">&lt;urn:test:&gt;</span>

<span class="uri">:c</span> <span class="uri">a</span> <span class="uri">:Circle</span> ;
   <span class="uri">:radius</span> <span class="number">10</span> .

<span class="uri">:t</span> <span class="uri">a</span> <span class="uri">:Triangle</span> ;
   <span class="uri">:base</span> <span class="number">4</span> ;
   <span class="uri">:height</span> <span class="number">10</span> .

<span class="uri">:r</span> <span class="uri">a</span> <span class="uri">:Rectangle</span> ;
   <span class="uri">:width</span> <span class="number">5</span> ;
   <span class="uri">:height</span> <span class="number">8</span> .

<span class="uri">:s</span> <span class="uri">a</span> <span class="uri">:Rectangle</span> ;
   <span class="uri">:width</span> <span class="number">10</span> ;
   <span class="uri">:height</span> <span class="number">10</span> .

[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
   <span class="uri">rule:content</span> <span class="string">"""
     PREFIX :&lt;urn:test:&gt;
     <span class="rule"><span class="keyword">IF</span> </span>{
        ?r a :Rectangle ;
           :width ?w ;
           :height ?h
        BIND (?w * ?h AS ?area)
     }
     <span class="rule"><span class="keyword">THEN</span> </span>{
         ?r :area ?area
     }"""</span> .

[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
   <span class="uri">rule:content</span> <span class="string">"""
     PREFIX :&lt;urn:test:&gt;
     <span class="rule"><span class="keyword">IF</span> </span>{
        ?t a :Triangle ;
           :base ?b ;
           :height ?h
        BIND (?b * ?h / 2 AS ?area)
     }
     <span class="rule"><span class="keyword">THEN</span> </span>{
         ?t :area ?area
     }"""</span> .

[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
   <span class="uri">rule:content</span> <span class="string">"""
     PREFIX :&lt;urn:test:&gt;
     PREFIX math: &lt;http://www.w3.org/2005/xpath-functions/math#&gt;
     <span class="rule"><span class="keyword">IF</span> </span>{
          ?c a :Circle ;
             :radius ?r
          BIND (math:pi() * math:pow(?r, 2) AS ?area)
     }
     <span class="rule"><span class="keyword">THEN</span> </span>{
         ?c :area ?area
     }"""</span> .


[] <span class="uri">a</span> <span class="uri">rule:SPARQLRule</span> ;
   <span class="uri">rule:content</span> <span class="string">"""
     PREFIX :&lt;urn:test:&gt;
     <span class="rule"><span class="keyword">IF</span> </span>{
          ?r a :Rectangle ;
             :width ?w ;
             :height ?h
          FILTER (?w = ?h)
     }
     <span class="rule"><span class="keyword">THEN</span> </span>{
         ?r a :Square
     }"""</span> .</code></pre>
<p>This example also demonstrates how to use SPARQL's <code>BIND</code> to introduce intermediate variables and do calculations with or to them.</p>
<p>Let's look at some other rules, but just the rule content this time for concision, to see some use of other SPARQL features.</p>
<p>This rule says that a person between 13 and 19 (inclusive) years of age is a teenager:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">PREFIX</span> swrlb: <span class="uri">&lt;http://www.w3.org/2003/11/swrlb#&gt;</span>
<span class="keyword">PREFIX</span> xsd: <span class="uri">&lt;http://www.w3.org/2001/XMLSchema#&gt;</span>

<span class="rule"><span class="keyword">IF</span> </span>{
      <span class="variable">?x</span> <span class="uri">a</span> <span class="uri">:Person</span>; hasAge <span class="variable">?age</span>.
      <span class="keyword">FILTER</span> (<span class="variable">?age</span> &gt;= <span class="number">13</span> &amp;&amp; <span class="variable">?age</span> <span class="uri">&lt;= 19)
}
THEN {
      ?x a :Teenager.
}</span></code></pre>
<p>This rule says that a male person with a sibling who is the parent of a female is an “uncle of a niece”:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
      <span class="variable">$x</span> <span class="uri">a</span> Person; <span class="uri">a</span> <span class="uri">:Male</span>; <span class="uri">:hasSibling</span> <span class="variable">$y</span>;
      <span class="variable">$y</span> <span class="uri">:isParentOf</span> <span class="variable">$z</span>;
      <span class="variable">$z</span> <span class="uri">a</span> <span class="uri">:Female</span>.
}
<span class="rule"><span class="keyword">THEN</span> </span>{
      <span class="variable">$x</span> <span class="uri">a</span> <span class="uri">:UncleOfNiece</span>.
}</code></pre>
<p>You can use SPARQL 1.1 property paths (and bnodes for unnecessary variables (that is, ones that aren't used in the <code>THEN</code>)) to render this rule even more concisely:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
      <span class="variable">$x</span> <span class="uri">a</span> <span class="uri">:Person</span>, <span class="uri">:Male</span>; <span class="uri">:hasSibling</span>/<span class="uri">:isParentOf</span> [<span class="uri">a</span> <span class="uri">:Female</span>]
}
<span class="rule"><span class="keyword">THEN</span> </span>{
      <span class="variable">$x</span> <span class="uri">a</span> <span class="uri">:UncleOfNiece</span>.
}</code></pre>
<p>Aside: that's pure awesome.</p>
<p>And of course a person who's male and has a niece or nephew is an uncle of his
niece(s) and nephew(s):</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
     <span class="variable">?x</span> <span class="uri">a</span> <span class="uri">:Male</span>; <span class="uri">:isSiblingOf</span>/<span class="uri">:isParentOf</span> <span class="variable">?z</span>
}
<span class="rule"><span class="keyword">THEN</span> </span>{
      <span class="variable">?x</span> <span class="uri">:isUncleOf</span> <span class="variable">?z</span>.
}</code></pre>
<p>A super user can read all of the things!</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
      <span class="variable">?x</span> <span class="uri">a</span> <span class="uri">:SuperUser</span>.
      <span class="variable">?y</span> <span class="uri">a</span> <span class="uri">:Resource</span>.
      <span class="variable">?z</span> <span class="uri">a</span> <span class="uri">&lt;http://www.w3.org/ns/sparql#UUID&gt;</span>.
}
<span class="rule"><span class="keyword">THEN</span> </span>{
      <span class="variable">?z</span> <span class="uri">a</span> <span class="uri">:Role</span>.
      <span class="variable">?x</span> <span class="uri">:hasRole</span> <span class="variable">?z</span>; <span class="uri">:readPermission</span> <span class="variable">?y</span>.
}</code></pre>
<h3>Supported Built-Ins</h3>
<p>Stardog supports a wide variety of functions from SPARQL, XPath, SWRL, and some native Stardog functions, too. All of them may be used in either Stardog Rules syntax or in SWRL syntax. The supported functions are enumerated <a href="/using/#functions">here</a>.</p>
<h2 id="sd-Special-Predicates">Special Predicates</h2>
<p>Stardog supports some builtin predicates with special meaning in order to queries and rules easier to read and write. These special predicates are primarily syntactic sugar for more complex structures.</p>
<h3>Direct/Strict Subclasses, Subproperties, &amp; Direct Types</h3>
<p>Besides the standard RDF(S) predicates <code>rdf:type</code>, <code>rdfs:subClassOf</code> and
<code>rdfs:subPropertyOf</code>, Stardog supports the following special built-in
predicates:</p>
<ul>
<li><code>sp:directType</code></li>
<li><code>sp:directSubClassOf</code></li>
<li><code>sp:strictSubClassOf</code></li>
<li><code>sp:directSubPropertyOf</code></li>
<li><code>sp:strictSubPropertyOf</code></li>
</ul>
<p>Where the <code>sp</code> prefix binds to <code>tag:stardog:api:property:</code>. Stardog also recognizes <code>sesame:directType</code>,
<code>sesame:directSubClassOf</code>, and <code>sesame:strictSubClassOf</code> predicates where the prefix <code>sesame</code> binds to
<code>http://www.openrdf.org/schema/sesame#</code>.</p>
<p>We show what these each of these predicates means by relating them to an
equivalent triple pattern; that is, you can just write the predicate rather than the (more unwieldy) triple pattern.</p>
<pre class="highlighted"><code class="sparql"><span class="comment"># c1 is a subclass of c2 but not equivalent to c2
</span>
<span class="uri">:c1</span> <span class="uri">sp:strictSubClassOf</span> <span class="uri">:c2</span>      =&gt;       <span class="uri">:c1</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:c2</span> .
                                          <span class="keyword">FILTER</span> <span class="keyword">NOT</span> EXISTS {
                                             <span class="uri">:c1</span> <span class="uri">owl:equivalentClass</span> <span class="uri">:c2</span> .
                                          }</code></pre>
<pre class="highlighted"><code class="sparql"><span class="comment"># c1 is a strict subclass of c2 and there is no c3 between c1 and c2 in the strict subclass hierarchy
</span>
<span class="uri">:c1</span> <span class="uri">sp:directSubClassOf</span> <span class="uri">:c2</span>      =&gt;       <span class="uri">:c1</span> <span class="uri">sp:strictSubClassOf</span> <span class="uri">:c2</span> .
                                          <span class="keyword">FILTER</span> <span class="keyword">NOT</span> EXISTS {
                                             <span class="uri">:c1</span> <span class="uri">sp:strictSubClassOf</span> <span class="uri">:c3</span> .
                                             <span class="uri">:c3</span> <span class="uri">sp:strictSubClassOf</span> <span class="uri">:c2</span> .
                                          }</code></pre>
<pre class="highlighted"><code class="sparql"><span class="comment"># ind is an instance of c1 but not an instance of any strict subclass of c1
</span>
<span class="uri">:ind</span> <span class="uri">sp:directType</span> <span class="uri">:c1</span>           =&gt;       <span class="uri">:ind</span> <span class="uri">rdf:type</span> <span class="uri">:c1</span> .
                                          <span class="keyword">FILTER</span> <span class="keyword">NOT</span> EXISTS {
                                             <span class="uri">:ind</span> <span class="uri">rdf:type</span> <span class="uri">:c2</span> .
                                             <span class="uri">:c2</span> <span class="uri">sp:strictSubClassOf</span> <span class="uri">:c1</span> .
                                          }</code></pre>
<p>The predicates <code>sp:directSubPropertyOf</code> and <code>sp:strictSubPropertyOf</code> are defined analogously.</p>
<h3>New Individuals with SWRL</h3>
<p>Stardog also supports a special predicate that extends the expressivity of SWRL rules. According to the SWLR spec,
you can't create new individuals (i.e., new instances of classes) in a SWRL rule.</p>
<p><strong>Note:</strong> Don‘t get hung up by the tech vocabulary here…“new individual” just means that you can’t have a rule
that adds a new instance of some RDF or OWL class as a result of the rule firing.</p>
<p>This restriction is well-motivated as it can easily cause rules to be non-terminating, that is, they never reach
a fixed point, which causes big problems. Stardog's user-defined rules weakens this restriction in some crucial
aspects, subject to the following restrictions, conditions, and warnings.</p>
<p><strong>This special predicate is basically a loaded gun with which you may shoot yourselves in the foot if you aren't very careful.</strong></p>
<p>So despite the general restriction in SWRL, in Stardog we actually can create new individuals with a rule by using
the function <code>UUID()</code> as follows:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Person</span> .
    BIND (UUID() <span class="keyword">AS</span> <span class="variable">?parent</span>) .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Parent</span> .
}</code></pre>
<p><strong>Note:</strong> Alternatively, we can use the predicate <code>&lt;http://www.w3.org/ns/sparql#UUID&gt;</code> as a unary SWRL built-in.</p>
<p>This rule will create a <em>random</em> URI for each instance of the class <code>:Person</code> and also assert that each new instance
is an instance of <code>:Parent</code>.</p>
<h4>Remarks</h4>
<ul>
<li>The URIs for the generated individuals are meaningless in the sense that they should not be used in further
queries; that is to say, these URIs are not guaranteed by Stardog to be stable.</li>
<li>Due to normalization, rules with more than one atom in the head are broken up into several rules. Thus,</li>
</ul>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Person</span> .
    BIND (UUID() <span class="keyword">AS</span> <span class="variable">?parent</span>) .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Parent</span> ;
            <span class="uri">a</span> <span class="uri">:Male</span> .
}</code></pre>
<p>will be normalized into two rules:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Person</span> .
    BIND (UUID() <span class="keyword">AS</span> <span class="variable">?parent</span>) .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Parent</span> .
}</code></pre>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Person</span> .
    BIND (UUID() <span class="keyword">AS</span> <span class="variable">?parent</span>) .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Male</span> .
}</code></pre>
<p>As a consequence, in this case, instead of stating that the new
individual is both an instance of <code>:Male</code> and <code>:Parent</code>, we would create
two <em>different</em> new individuals, and assert that one is male and the
other is a parent. If you need to assert various things about the new
individual, we recommend the use of extra rules/axioms. In the previous
example, we can introduce a new class (<code>:Father</code>) and add the following
rule to our schema:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Father</span> .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Parent</span> ;
            <span class="uri">a</span> <span class="uri">:Male</span> .
}</code></pre>
<p>And then modify the original rule accordingly:</p>
<pre class="highlighted"><code class="sparql"><span class="rule"><span class="keyword">IF</span> </span>{
    <span class="variable">?person</span> <span class="uri">a</span> <span class="uri">:Person</span> .
    BIND (UUID() <span class="keyword">AS</span> <span class="variable">?parent</span>) .
}
<span class="rule"><span class="keyword">THEN</span> </span>{
    <span class="variable">?parent</span> <span class="uri">a</span> <span class="uri">:Father</span> .
}</code></pre>
<h2 id="sd-Query-Rewriting">Query Rewriting</h2>
<p>Reasoning in Stardog is based (mostly) on a <em>query rewriting</em>
technique: Stardog rewrites the user's query with respect to any schema or rules, and then executes the resulting expanded query (EQ) against the data in the normal way. This process is completely automated and requires no intervention from the user per se.</p>
<p>As can be seen in Figure 2, the rewriting process involves five different phases.</p>
<p><img src="/img/blackout.png" alt=""></p>
<p>Figure 1. Query Answering</p>
<p><img src="/img/blackout-internals.png" alt=""></p>
<p>Figure 2. Query Rewriting</p>
<p>We illustrate the query answering process by means of an example.
Consider a Stardog database, MyDB<sub>1</sub>, containing the following schema:</p>
<pre class="highlighted"><code class="manchester"> <span class="uri">:SeniorManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:manages</span> <span class="built_in">some</span> <span class="uri">:Manager</span>
 <span class="uri">:manages</span> <span class="built_in">some</span> <span class="uri">:Employee</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
 <span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span></code></pre>
<p>Which says that a senior manager manages at least one manager, that
every person that manages an employee is a manager, and that every
manager is also an employee.</p>
<p>Let's also assume that MyDB<sub>1</sub>
contains the following data assertions:</p>
<pre class="highlighted"><code class="manchester"><span class="uri">:Bill</span> <span class="uri">rdf:type</span> <span class="uri">:SeniorManager</span>
<span class="uri">:Robert</span> <span class="uri">rdf:type</span> <span class="uri">:Manager</span>
<span class="uri">:Ana</span> <span class="uri">:manages</span> <span class="uri">:Lucy</span>
<span class="uri">:Lucy</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span></code></pre>
<p>Finally, let's say that we want to retrieve the set of all
employees. We do this by posing the following query:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span> }</code></pre>
<p>To answer this query, Stardog first <strong>rewrites</strong> it using the information in the schema. So the original query is rewritten into four queries:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span> }
<span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:Manager</span> }
<span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:SeniorManager</span> }
<span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">:manages</span> <span class="variable">?x</span>. <span class="variable">?x</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span> }</code></pre>
<p>Then Stardog executes these queries over the data.</p>
<p>The form of the EQ depends on the reasoning level. For OWL 2 QL, every
EQ produced by Stardog is <strong>guaranteed to be expanded into a set of
queries</strong>. If the reasoning level is OWL 2 RL or EL, then the EQ <em>may</em>
(but may not) include a recursive rule. If a recursive rule is included,
Stardog's answers will be sound but incomplete with respect to the
semantics of the reasoning level.<a id="fn-ref-5" href="#footnote-5" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-5"><sup>5</sup></a></p>
<h3>Why Query Rewriting?</h3>
<p>Query rewriting has several advantages over the alternative
technique, materialization. In materialization, the data
gets expanded with respect to the schema, not the query. The
schema is used to generate new triples, typicaly when data is added or removed from the system. However, materialization introduces some issues:</p>
<ul>
<li><strong>data freshness</strong>. Materialization has to be performed every time
the data or the schema change. This is particularly unsuitable for
applications where the data changes frequently.</li>
<li><strong>data size</strong>. Depending on the schema, materialization can
significantly increase the size of the data. A relatively simple
class hierarchy with a single level of subclasses increases the
size of the data.</li>
<li><strong>OWL 2 profile reasoning</strong>. Given the fact that QL, RL, and EL, are
not comparable with respect to expressive power, an application that
requires reasoning with more than one profile would need to maintain
different corresponding materialized versions of the data.</li>
<li><strong>Resources</strong>. Depending on the size of the original data and the
complexity of the schema, materialization can be computationally
expensive.</li>
</ul>
<h2 id="sd-Performance-Hints">Performance Hints</h2>
<p>The query rewriting approach suggests some guidelines for more efficient query answering.</p>
<h3>Hierarchies and Queries</h3>
<p><strong>Avoid unnecessarily deep class/property hierarchies</strong>. If you do not
need to model several different types of a given class or property in
your schema, then don't do that! The reason shallow hierarchies are desirable
is that the maximal hierarchy depth in the ontology partly determines
the maximal size of the EQs produced by Stardog. The larger the EQ, the
more difficult it is to evaluate, generally.</p>
<p>For example, suppose our schema contains a very thorough and detailed
set of subclasses of the class <code>:Employee</code>:</p>
<pre class="highlighted"><code class="manchester"><span class="uri">:Manager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:SeniorManager</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Manager</span>
...

<span class="uri">:Supervisor</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
<span class="uri">:DepartmentSupervisor</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Supervisor</span>
...

<span class="uri">:Secretary</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Employee</span>
...</code></pre>
<p>If we wanted to retrieve the set of all employees, Stardog would
produce an EQ containing a query of the following form for every
subclass <code>:Ci</code> of <code>:Employee</code>:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:Ci</span> }</code></pre>
<p>Thus, <strong>the more specific the query, the better</strong>. Why? More general queries—that is, queries that contain concepts high up in the class hierarchy defined by the schema—will typically yield larger EQs.</p>
<h3>Domains and Ranges</h3>
<p><strong>Specify domain and range of the properties in the schema</strong>. These
types of axiom can help reduce the size of the EQs significantly. Why?</p>
<p>Consider the following query asking for people and the employees they manage:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?manager</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span>
  { <span class="variable">?manager</span> <span class="uri">:manages</span> <span class="variable">?employee</span>.
    <span class="variable">?employee</span> <span class="uri">rdf:type</span> <span class="uri">:Employee</span>. }</code></pre>
<p>We know that this query would cause a large EQ given a deep hierarchy
of <code>:Employee</code> subclasses. However, if we added the following single
range axiom:</p>
<pre class="highlighted"><code class="manchester">      <span class="uri">:manages</span> <span class="uri">rdfs:range</span> <span class="uri">:Employee</span></code></pre>
<p>then the EQ would collapse to:</p>
<pre class="highlighted"><code class="sparql"> <span class="keyword">SELECT</span> <span class="variable">?manager</span> <span class="variable">?employee</span> <span class="keyword">WHERE</span> { <span class="variable">?manager</span> <span class="uri">:manages</span> <span class="variable">?employee</span> }</code></pre>
<p>which is considerably cheaper to evaluate.</p>
<h2 id="sd-Not-Seeing-Expected-Results-">Not Seeing Expected Results?</h2>
<p>Here's a few things that you might want to know about.</p>
<h3>Are variable types ambiguous?</h3>
<p>When a SPARQL query gets executed, each variable is bound to a URI, blank node,
or literal to form a particular result (a collection of these results is known
as a result set). In the context of reasoning, URIs might represent different
entities: individuals, classes, properties, etc. According to the <a href="http://www.w3.org/TR/sparql11-entailment/#OWLDSEnRegime">relevant standard</a>, <strong>every variable in a SPARQL query must bind to at most one of these types of entity</strong>.</p>
<p>Stardog can often figure out the right entity type from the query itself (e.g., given the
triple pattern <code>?i ?p "a literal"</code>, we know <code>?p</code> is supposed to bind to a data
property); however, some times this isn't possible (e.g., <code>?s ?p ?o</code>). In case
the types can't be determined automatically, <strong>Stardog logs a message and evaluates the
query without any reasoning</strong>.</p>
<p>You can add one or more type triples to the query to resolve these ambiguities.<a id="fn-ref-6" href="#footnote-6" class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#footnote-6"><sup>6</sup></a> </p>
<p>These “type triples” have the orm <code>?var a TYPE</code>, where <code>TYPE</code> is a
URI representing the type of entity to which the variable <code>?var</code> is supposed to
bind: the most common are <code>owl:ObjectProperty</code> or <code>owl:DatatypeProperty</code>; in some cases, you might want <code>owl:NamedIndividual</code>, or <code>owl:Class</code>. For instance, if you are interested in all the
object properties of <code>:i1</code>, you can use the following
query:</p>
<pre class="highlighted"><code class="sparql">    <span class="keyword">SELECT</span> <span class="variable">?o</span> 
    <span class="keyword">WHERE</span> { 
        <span class="uri">:i1</span> <span class="variable">?p</span> <span class="variable">?o</span>. 
        <span class="variable">?p</span> <span class="uri">a</span> <span class="uri">owl:ObjectProperty</span>.
    }.</code></pre>
<p>Since Stardog now knows that <code>?p</code> should bind to an object property, we can now infer that <code>?o</code> binds to an individual, so there are no ambiguities and reasoning can be performed as requested.</p>
<h3>Is the schema where you think it is?</h3>
<p>Stardog might be extracting the wrong schema. You have to tell Stardog where to find the schema. See <a href="#tbox_extraction">Schema Extraction</a> for details.</p>
<h3>Are you using the right reasoning level?</h3>
<p>Perhaps some of the modeling constructs (a.k.a. axioms) in your database are being ignored. You can find out which axioms are being ignored due to the reasoning level used by simply including the following line in the logging.properties file in <code>STARDOG_HOME</code>:</p>
<pre class="highlighted"><code class="java">        com.clarkparsia.blackout.level = ALL</code></pre>
<h3>Are you using DL?</h3>
<p>Stardog supports schema-only reasoning for OWL 2 DL, which effectively means that only TBox queries—queries that contain <a href="#query_types">TBox BGPs</a> only—will return complete query results.</p>
<h3>Are you using SWRL?</h3>
<p>As from version 2.0, SWRL rules are only taken into account using the <strong>SL</strong> reasoning level.</p>
<h3>Do you know what to expect?</h3>
<p>The <a href="http://www.w3.org/TR/owl2-primer/">OWL 2 primer</a> is always a good place to start.</p>
<h2 id="sd-Known-Issues">Known Issues</h2>
<p>Stardog 2.2.2 does not</p>
<ul>
<li>Follow ontology <code>owl:imports</code> statements automatically; any imported
OWL ontologies that are required for reasoning must be loaded into a
Stardog database in the normal way.</li>
<li>Handle recursive queries. If recursion is necessary to answer the
query with respect to the schema, results will be sound (no wrong
answers) but potentially incomplete (some correct answers not
returned) with respect to the requested reasoning type.</li>
<li>Perform equality reasoning. Only <em>explicit</em> <code>owl:sameAs</code> and
<code>owl:differentFrom</code> data assertions will be taken into account for
query answering.</li>
<li>Perform datatype reasoning or respect user-defined datatypes.</li>
</ul>
<h2 id="sd-Terminology">Terminology</h2>
<p>This chapter uses the following terms of art.</p>
<h3>Databases</h3>
<p>A <em>database</em> (DB), a.k.a. ontology, is composed of two different parts:
the schema or <em>Terminological Box</em> (TBox) and the data or <em>Assertional
Box</em> (ABox). Analogus to relational databases, the TBox can be thought
of as the schema, and the ABox as the data. In other words, the TBox is
a set of <em>axioms</em>, whereas the ABox is a set of <em>assertions</em>.</p>
<p>As we explain in <a href="#profiles">Section OWL 2 Profiles</a>, the kinds of
assertion and axiom that one might use for a particular database are
determined by the fragment of OWL 2 to which one would like to adhere.
In general, you should choose the OWL 2 profile that most closely fits
the data modeling needs of your application.</p>
<p>The most common data assertions are class and property assertions. Class
assertions are used to state that a particular individual is an instance
of a given class. Property assertions are used to state that two
particular individuals (or an individual and a literal) are related via
a given property. For example, suppose we have a DB MyDB<sub>2</sub> that
contains the following data assertions:We use the usual standard
prefixes for RDF(S) and OWL.</p>
<pre class="highlighted"><code class="manchester"><span class="uri">:clark_and_parsia</span> <span class="uri">rdf:type</span> <span class="uri">:Company</span>
<span class="uri">:clark_and_parsia</span> <span class="uri">:maintains</span> <span class="uri">:Stardog</span></code></pre>
<p>stating that <code>:clark_and_parsia</code> is a company, and that
<code>:clark_and_parsia</code> maintains <code>:Stardog</code>.</p>
<p>The most common schema axioms are subclass axioms. Subclass axioms are
used to state that every instance of a particular class is also an
instance of another class. For example, suppose that MyDB<sub>2</sub> contains
the following TBox axiom:</p>
<pre class="highlighted"><code class="manchester"><span class="uri">:Company</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Organization</span></code></pre>
<p>stating that companies are a type of organization.</p>
<h3>Queries</h3>
<p>When reasoning is enabled, Stardog executes SPARQL queries (simply
queries from now on) depending on the type of Basic Graph Patterns they
contain.</p>
<p>A BGP is said to be an ABox BGP if it is of one of the following forms:</p>
<ul>
<li><strong>term<sub>1</sub></strong> <code>rdf:type</code> <strong>uri</strong></li>
<li><strong>term<sub>1</sub></strong> <strong>uri</strong> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:differentFrom</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:sameAs</code> <strong>term<sub>2</sub></strong></li>
</ul>
<p>A BGP is said to be a TBox BGP if it is of one of the following forms:</p>
<ul>
<li><strong>term<sub>1</sub></strong> <code>rdfs:subClassOf</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:disjointWith</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:equivalentClass</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>rdfs:subPropertyOf</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:equivalentProperty</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:inverseOf</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>owl:propertyDisjointWith</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>rdfs:domain</code> <strong>term<sub>2</sub></strong></li>
<li><strong>term<sub>1</sub></strong> <code>rdfs:range</code> <strong>term<sub>2</sub></strong></li>
</ul>
<p>A BGP is said to be a Hybrid BGP if it is of one of the following forms:</p>
<ul>
<li><strong>term<sub>1</sub></strong> <code>rdf:type</code> <strong>?var</strong></li>
<li><strong>term<sub>1</sub></strong> <strong>?var</strong> <strong>term<sub>2</sub></strong></li>
</ul>
<p>where <strong>term</strong> (possibly with subscripts) is either an URI or variable;
<strong>uri</strong> is a URI; and <strong>?var</strong> is a variable.</p>
<p>When executing a query, ABox BGPs are handled by Stardog. TBox BGPs are
executed by Pellet embedded in Stardog. Hybrid BGPs by a combination of both.</p>
<h3>Reasoning</h3>
<p>Intuitively, reasoning with a DB means to make implicit knowledge
explicit. There are two main use cases for reasoning: infer implicit
knowledge and to discover modeling errors.</p>
<p>With respect to the first use case, recall that MyDB<sub>2</sub> contains the
following assertion and axiom:</p>
<pre class="highlighted"><code class="manchester"> <span class="uri">:clark_and_parsia</span> <span class="uri">rdf:type</span> <span class="uri">:Company</span>
 <span class="uri">:Company</span> <span class="uri">rdfs:subClassOf</span> <span class="uri">:Organization</span></code></pre>
<p>From this DB, we can use Stardog in order to <em>infer</em> that
<code>:clark_and_parsia</code> is an organization:</p>
<pre class="highlighted"><code class="asciidoc"><span class="attribute">:clark_and_parsia rdf:type</span> :Organization</code></pre>
<p>Using reasoning in order to infer implicit knowledge in the context of
an enterprise application can lead to simpler queries. Let us suppose,
for example, that MyDB<sub>2</sub> contains a complex class hierarchy including
several types of organization (including company). Let us further
suppose that our application requires to use Stardog in order to get the
list of all considered organizations. If Stardog were used <strong>with
reasoning</strong>, then we would need only issue the following simple query:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?org</span> <span class="keyword">WHERE</span> { <span class="variable">?org</span> <span class="uri">rdf:type</span> <span class="uri">:Organization</span>}</code></pre>
<p>In contrast, if we were using Stardog <strong>with no reasoning</strong>, then we
would have to issue the following considerably more complex query that
considers all possible types of organization:</p>
<pre class="highlighted"><code class="sparql"><span class="keyword">SELECT</span> <span class="variable">?org</span> <span class="keyword">WHERE</span>
              { { <span class="variable">?org</span> <span class="uri">rdf:type</span> <span class="uri">:Organization</span> } UNION
              { <span class="variable">?org</span> <span class="uri">rdf:type</span> <span class="uri">:Company</span> } UNION
...
}</code></pre>
<p>Stardog can also be used in order to discover modeling errors in a DB.
The most common modeling errors are <em>unsatisfiable</em> classes and
<em>inconsistent</em> DBs.</p>
<p>An unsatisfiable class is simply a class that cannot have any instances.
Say, for example, that we added the following axioms to MyDB<sub>2</sub>:</p>
<pre class="highlighted"><code class="manchester"> <span class="uri">:Company</span> <span class="uri">owl:disjointWith</span> <span class="uri">:Organization</span>
 <span class="uri">:LLC</span> <span class="uri">owl:equivalentClass</span> <span class="uri">:Company</span> <span class="built_in">and</span> <span class="uri">:Organization</span></code></pre>
<p>stating that companies cannot be organizations and vice versa, and that
an LLC is a company and an organization. The disjointness axiom causes
the class <code>:LLC</code> to be unsatisfiable because, for the DB to be
free of any logical contradiction, there can be no instances of <code>:LLC</code>.</p>
<p>Asserting (or inferring) that an unsatisfiable class has an instance,
causes the DB to be <em>inconsistent</em>. In the particular case of MyDB<sub>2</sub>,
we know that <code>:clark_and_parsia</code> is a company <em>and</em> an organization (see
above); therefore, we also know that it is an instance of <code>:LLC</code>, and as
<code>:LLC</code> is known to be unsatisfiable, we have that MyDB<sub>2</sub> is
inconsistent.</p>
<p>Using reasoning in order to discover modeling errors in the context of
an enterprise application is useful in order to maintain a correct
contradiction-free model of the domain. In our example, we discovered
that <code>:LLC</code> is unsatisfiable and MyDB<sub>2</sub> is inconsistent, which leads us
to believe that there is a modeling error in our DB. In this case, it is
easy to see that the problem is the disjointness axiom between
<code>:Company</code> and <code>:Organization</code>.</p>
<h3>OWL 2 Profiles</h3>
<p>As explained in the <a href="http://www.w3.org/TR/owl2-profiles/">OWL 2 Web Ontology Language Profiles
Specification</a> of the W3C, an OWL 2
profile is a trimmed down version of OWL 2 that trades some expressive
power for the efficiency of reasoning. There are three OWL 2 profiles,
each of which achieves efficiency differently.</p>
<ul>
<li><a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_QL">OWL 2 QL</a> is aimed at
applications that use very large volumes of instance data, and where
query answering is the most important reasoning task. The expressive
power of the profile is necessarily limited, however it includes
most of the main features of conceptual models such as UML class
diagrams and ER diagrams.</li>
<li><a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_EL">OWL 2 EL</a> is
particularly useful in applications employing ontologies that
contain very large numbers of properties and/or classes. This
profile captures the expressive power used by many such ontologies
and is a subset of OWL 2 for which the basic reasoning problems can
be performed in time that is polynomial with respect to the size of
the ontology.</li>
<li><a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_RL">OWL 2 RL</a> is aimed at
applications that require scalable reasoning without sacrificing too
much expressive power. It is designed to accommodate OWL 2
applications that can trade the full expressivity of the language
for efficiency, as well as RDF(S) applications that need some added
expressivity.</li>
</ul>
<p>Each profile restricts the kinds of axiom and assertion that can be used
in a DB. Intuitively, QL is the least expressive of the profiles,
followed by RL and EL; however, strictly speaking, no profile is more
expressive than any other as they provide incomparable sets of
constructs.</p>
<p>Stardog supports the three profiles of OWL 2. Notably, since TBox BGPs are handled completely by Pellet, Stardog supports reasoning for the whole of OWL 2 for queries containing TBox BGPs only.</p>

          </div>
          <div class="" id="footnote-container" style="display: block;">
            <h2>Notes</h2>
          <div class="footnote" id="footnote-1"><p>1. Triggered using the <code>--format tree</code> option of the <code>reasoning explain</code> CLI command.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-1">&nbsp;&#8618;</a></p></div><div class="footnote" id="footnote-2"><p>2. Quick refresher: the <code>IF</code> clause defines the conditions to match in the
data; if they match, then the contents of the <code>THEN</code> clause “fire”, that is,
they are inferred and, thus, available for other queries, rules, or axioms,
etc.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-2">&nbsp;&#8618;</a></p></div><div class="footnote" id="footnote-3"><p>3. Of course if you&#39;ve tweaked <code>reasoning.schema.graphs</code>, then you
should put the rules into the named graphs that are specifed
in that configuration parameter.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-3">&nbsp;&#8618;</a></p></div><div class="footnote" id="footnote-4"><p>4. We&#39;ll produce a complete tutorial and spec for an upcoming 2.0.x release.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-4">&nbsp;&#8618;</a></p></div><div class="footnote" id="footnote-5"><p>5. We‘re working on changes to Stardog’s reasoner so that it&#39;s complete in the case where recursive rules exist; these changes will be available in the 2.x release cycle.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-5">&nbsp;&#8618;</a></p></div><div class="footnote" id="footnote-6"><p>6. These are harmless and won&#39;t otherwise affect query evaluation; they can also be added to the data, instead of to queries, if that fits yr use case better.<a class="skip fn-marker" gumby-easing="easeOutQuad" gumby-duration="400" gumby-goto="#fn-ref-6">&nbsp;&#8618;</a></p></div></div>
        </div>
    </div>
  </div>
</div>


<div class="wrapper shaded" id="subfoot">
      <section class="row">
        <div class="twelve columns">
            <div class="four columns">
              <a style="text-decoration: none; border-bottom: 0;" href="http://clarkparsia.com/"><img id="footer-logo" style="max-width: 50%;" src="/img/cp.png"></a>
              <div> </div>
              <!-- follow us on Twitter -->
            </div>
            <div class="eight columns">
              
                <h4>This is <span id="footer-subhead">OWL & Rule Reasoning</span>, part of <a href="http://docs.stardog.com/">Stardog Docs</a> 2.2.2.</h4>
              
              <p class="copywood">For comments, questions, or to report problems with this page, visit the <a href="https://groups.google.com/a/clarkparsia.com/group/stardog/about">Stardog Support Forum</a>.</p>
              <p class="copywood">&copy;2010&ndash;2014 Clark &amp; Parsia LLC. <a href="http://creativecommons.org/licenses/by-sa/3.0/">Some rights reserved</a>.
            </p></div>
        </div>
      </section>
</div>

<script defer="defer" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script defer="defer" src="/js/libs/gumby.js"></script><script defer="defer" src="/js/libs/ui/gumby.fittext.js"></script><script defer="defer" src="/js/libs/ui/gumby.fixed.js"></script><script defer="defer" src="/js/libs/ui/gumby.navbar.js"></script><script defer="defer" src="/js/libs/ui/gumby.retina.js"></script><script defer="defer" src="/js/libs/ui/gumby.skiplink.js"></script><script defer="defer" src="/js/libs/ui/gumby.tabs.js"></script><script defer="defer" src="/js/libs/ui/gumby.toggleswitch.js"></script><script defer="defer" src="/js/libs/gumby.init.js"></script><script defer="defer" src="/js/plugins.js"></script><script defer="defer" src="/js/main.js"></script>

</body>

</html>