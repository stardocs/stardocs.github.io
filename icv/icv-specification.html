<!DOCTYPE html> 

<head>
  <title>Validating Semantic Web Data with OWL Integrity Constraints</title>
    <meta charset="utf-8" />
    <script type="text/javascript" src="http://use.typekit.com/muj3mlu.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link media="screen" rel="stylesheet" href="/_/css/ps.css" />
    <link media="print" rel="stylesheet" href="/_/css/print.css" />
    <style>
      table { border: 1px solid black }
      td, th {border-bottom: 1px solid gray }
    </style>
	<script type="text/javascript">

		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-1719955-3']);
		_gaq.push(['_setDomainName', 'stardog.com']);
		_gaq.push(['_trackPageview']);

		(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();

	</script>
</head>

<body>

<div class="head"> 
<h1 style="font-size: 22pt" id="title">Validating RDF with OWL Integrity Constraints</h1> 
 
<dl>
<dt>Authors:</dt>
<dd><a href="http://clarkparsia.com/about/profiles/hector/">H&#233;ctor
		P&#233;rez-Urbina</a>, Clark &#38; Parsia, LLC</dd>
<dd><a href="http://clarkparsia.com/about/profiles/evren/">Evren Sirin</a>, Clark &#38; Parsia, LLC</dd>
<dd><a href="http://clarkparsia.com/about/profiles/kendall/">Kendall Clark</a>, Clark &#38; Parsia, LLC</dd>
</dl>

</div>

<h2 id="abstract">Abstract</h2> 
 
<p>This document proposes a method for validating Semantic Web and Linked   
Data by providing an alternative, integrity constraint (IC) semantics for   
OWL. A model-theoretic semantics based on the Closed World Assumption       
and a weak variant of the Unique Name Assumption is given for OWL axioms    
that are thereby interpreted as ICs. The document includes a structural     
specification in order to augment an ontology with a set of OWL ICs and a   
brief description of possible implementation approaches.</p>                

<div id="tableOfContents"> 
<h2 id="toc">Table of Contents</h2> 

<ul class="toc">
  <li class="tocline1">1. <a href="#_1">Introduction</a>   </li>
  <li class="tocline1">2. <a href="#_2">Structural Specification</a> </li>
  <li class="tocline1">3. <a href="#_3">OWL IC Semantics</a>
    <ul class="toc">
		<li class="tocline2">3.1 <a href="#_3.1">IC-Interpretations</a></li>
		<li class="tocline2">3.2 <a href="#_3.2">Axiom Satisfaction</a></li>
		<li class="tocline2">3.3 <a href="#_3.3">Axiom IC-Satisfaction</a></li>
                <li class="tocline2">3.4 <a href="#_3.4">Inference Problem</a></li>
    </ul>
</li><!--
  <li class="tocline1">4. <a href="#_4">IC Examples</a>
  <ul class="toc">
		<li class="tocline2">4.1 <a
		  href="#_4.1">Simple Subsumption Constraints</a></li>
		<li class="tocline2">4.2 <a
		  href="#_4.2">Typing Constraints</a></li>
		<li class="tocline2">4.3 <a
		  href="#_4.3">Participation Constraints</a></li>  
		<li class="tocline2">4.4 <a
		  href="#_4.4">Cardinality Constraints</a></li>
		<li class="tocline2">4.5 <a
		  href="#_4.5">Role Constraints</a></li>  
		<li class="tocline2">4.6 <a
      href="#_4.6">Complex Constraints</a></li>  -->
  <li class="tocline1">4. <a href="#_5">Implementation Remarks</a> 
  <ul class="toc">
	<li class="tocline2">4.1 <a  href="#_5.1">Implementing IC Syntax</a></li>
        <li class="tocline2">4.2 <a  href="#_5.2">Implementing IC Semantics</a></li>
 </ul> </li>
  <li class="tocline1"><a href="#acknowledgments">Acknowledgments</a> </li>
  <li class="tocline1"><a href="#references">References</a> </li>
  <li class="tocline1"><a href="#appendix">Appendix</a> </li>
</ul>
</div>

<div id="introduction">
<h2><a name="1" id="_1"></a>1. Introduction </h2>

<p>This document proposes a method of constraining and validating Semantic  
Web and Linked Data (i.e., RDF) instance data using Integrity Constraints   
(ICs) modeled as OWL axioms. The proposal enables an OWL ontology to be     
interpreted as a set of ICs; i.e., checks that must be satisfied by the     
information explicitly present or information that may be inferred. We      
define a model-theoretic semantics for OWL ICs based on the Closed World    
Assumption and a weak variant of the Unique Name Assumption and briefly     
describe feasible implementation strategies.</p>                            

<p>In some use cases and for some requirements, OWL users intend OWL
axioms to be interpreted as ICs. However, the direct semantics of OWL
[<cite><a href="#owl-2-direct-semantics">OWL 2 Direct
Semantics</a></cite>] does not interpret OWL axioms in this way; thus,
the consequences that one can draw from such ontologies differ from
the ones that some users intuitively expect and require.

In other words, some users want to use OWL as a validation or constraint    
language for RDF instance data, but that is not possible using OWL          
software that correctly implements the existing semantics of OWL.           
This document addresses that situation by providing a different             
semantics&#8212;compatible with the existing semantics&#8212;for OWL axioms 
which may be used, together with appropriate software, to validate RDF      
instance data.</p>                                                          

<p>To see the nature of the problem, consider an OWL ontology that
  describes terms and concepts regarding the product inventory of a
  supermarket. The ontology includes the classes <i>Product</i>
  and <i>Provider</i>, the object property
<i>hasProvider</i>, and the data property <i>hasID</i>. Suppose we want to
impose the following ICs on the data: </p>
<ol style="list-style-type:upper-roman">
  <li>Each product must have an ID</li>
  <li>Only products can have IDs</li>
  <li>Products must not have more than one provider</li>
</ol>

<p>These constraints could be interpreted in the following way:</p>         

  <ol style="list-style-type:upper-roman">
    <li>Whenever an instance <i>product<sub>i</sub></i> of
      <i>Product</i> is added to the ontology, a check should be
      performed to verify whether the ID of <i>product<sub>i</sub></i>
      has been specified; if not, the update should be rejected.</li>

    <li>Whenever an instance
<i>&#60;product<sub>i</sub>, ID<sub>i</sub>&#62;</i> of <i>hasID</i> is added to
the ontology, a check should be performed to verify whether
<i>product<sub>i</sub></i> is an instance of <i>Product</i>; if not, the update
should be rejected.</li>

    <li>Whenever an instance
<i>&#60;product<sub>i</sub>, provider<sub>i</sub>&#62;</i>
of <i>hasProvider</i> is added to the ontology, a check should be
performed to verify whether another
provider <i>provider<sub>j</sub></i> has been specified for
<i>product<sub>i</sub></i>; if so, the update should be rejected.</li></ol>

<p>These constraints can be concisely and unambiguously represented as
OWL axioms: </p>

<ol style="list-style-type:upper-roman">
  <li><pre>Class: Product <br /> hasID some literal</pre>
  </li>
  <li><pre>DataProperty: hasID <br /> Domain: Product</pre>
  </li>
  <li><pre>ObjectProperty: hasProvider <br /> Characteristics: Functional</pre>
  </li>
</ol>

<p>However, these axioms will not be interpreted as checks by software
which implements the standard OWL semantics. In fact, according to the standard OWL semantics, we have that:</p>

<ol style="list-style-type:upper-roman">
  <li>Adding a product without an ID to the ontology does not raise an
error, but leads to the inference that the product in question has an
unknown ID.</li>
  <li>Adding a tuple <i>&#60;product<sub>i</sub>,
ID<sub>i</sub>&#62;</i> to the ontology
without <i>product<sub>i</sub></i> being an instance of <i>Product</i>
does not raise an error, but leads to the inference
that <i>product<sub>i</sub></i> is an instance of <i>Product</i>.</li>
  <li>Adding a tuple <i>&#60;product<sub>i</sub>,
provider<sub>i</sub>&#62;</i> having specified a previous provider
<i>provider<sub>j</sub></i> for <i>product<sub>i</sub></i> does not raise an
error, but leads to the inference that <i>provider<sub>i</sub></i> and
<i>provider<sub>j</sub></i> denote the same individual.</li>
</ol>

<p>In some cases, users want these inferences; but in others,
users want integrity constraint violations to be detected, reported,
repaired, etc.</p>

<p>OWL adopts the Open World Assumption (OWA) and does not adopt the
Unique Name Assumption (UNA). These design choices make it very
difficult to treat these axioms as ICs. On the one hand, due to OWA, a
statement must not be inferred to be false on the basis of failures to
prove it; therefore, the fact that a piece of information has not been
specified (e.g., a product's ID) does not mean that such information
does not exist. On the other hand, the absence of UNA allows two
different constants to refer to the same individual (e.g.,
<i>provider<sub>i</sub></i> and <i>provider<sub>j</sub></i>).</p>

<p>The standard interpretation of OWL axioms that are intended to be
interpreted as ICs is inappropriate for some use cases and applications;
therefore, it is useful to define an alternate semantics for OWL based
on IC. An IC semantics together with associated software will increase
the number of satisfied users of OWL because OWL and the software will
then behave as those users intuitively expect and require.</p>

<p>As formally defined in <a href="#_2">Section 2</a>, our approach allows 
for a standard OWL ontology <i>O</i> to import a set of IC ontologies&#8212;OWL 
ontologies that are to be interpreted as ICs. Note that the IC semantics for OWL
defined in this document is a strict extension of the standard OWL semantics:
in case <i>O</i> imports no IC ontology, then <i>O</i> should be 
interpreted as a standard OWL ontology.</p>

</div>

<div id="structural_specification">

<h2><a name="2" id="_2"></a>2. Structural Specification </h2>

<p>An OWL ontology that is to be interpreted as a set of ICs is called
an <em>IC ontology</em>. We slightly extend the structural
specification of OWL in order to allow ontologies to import a set of
IC ontologies. We do so by introducing a new annotation property which
is defined analogously to <span class="tt">owl:imports</span>&#8212;the annotation
property that is used to import standard ontologies defined by OWL 2
[<cite><a href="#ref-owl-2-specification">OWL 2
Specification</a></cite>].</p>

<p>We use an annotation property that resembles <span class="tt">owl:imports</span>
with a different namespace: <span class="tt">http://www.w3.org/Submission/owlic/</span>. In the following, we
denote this annotation property as <span class="tt">ic:imports</span> for
brevity.</p>

<p>An example usage of this annotation property is given in the following:</p>

<pre>
Namespace(ic = &#60;http://www.w3.org/Submission/owlic/&#62;)
Ontology(&#60;http://www.example.com/instanceOntology&#62;
	Import(&#60;http://www.example.com/schemaOntology&#62;)
	Annotation(ic:imports &#60;http://www.example.com/constraintsOntology&#62;)
	...
)</pre>

<p>where <span class="tt">instanceOntology</span> imports the standard axioms
of <span class="tt">schemaOntology</span> and imports <span class="tt">constraintsOntology</span> as
an IC ontology. This import approach to relating ICs to other OWL
ontologies gives enough flexibility to users without too much
maintenance cost and negligible impact on existing
tools. See <a href="#_5">Implementation Remarks</a> for a more
detailed discussion of this design choice.</p>

<p>An OWL ontology can import a set of IC ontologies
via <span class="tt">ic:imports</span>. An IC ontology can import a set of IC
ontologies via <span class="tt">ic:imports</span> as well. And, of course, an IC
ontology can import a set of standard ontologies
via <span class="tt">owl:imports</span> as usual.</p>

<p>The <i>import closure</i> of an IC ontology is defined in the same vein as the import closure 
for standard OWL ontologies. The <i>IC import closure</i> of a standard or IC ontology <i>O</i> is a set 
containing all the IC ontologies that <i>O</i> imports via the <span class="tt">ic:imports</span> annotation 
property. The <i>IC closure</i> of a standard or IC ontology <i>O</i> is the smallest set that 
contains all the axioms from each ontology <i>O'</i> in the IC import closure of <i>O</i>.</p>
</div>

<div id="semantics">
<h2><a name="3" id="_3"></a>3. OWL IC Semantics</h2>

<p>We refer to the definitions of datatype map, vocabulary, and OWL
interpretation and model in OWL 2
[<cite><a href="#owl-2-direct-semantics">OWL 2 Direct
Semantics</a></cite>].</p>

<h3><a name="3.1" id="_3.1"></a>3.1 IC-Interpretations </h3>

<p>Let <i>D</i> = (<i>N<sub>DT</sub></i>, <i>N<sub>LS</sub></i>, <i>N<sub>FS</sub></i>, <i>&#183;<sup>DT</sup></i>, <i>&#183;<sup>LS</sup></i>, <i>&#183;<sup>FS</sup></i>) be a datatype map and let <i>V</i> = (<i>V<sub>C</sub></i>, <i>V<sub>OP</sub></i>, <i>V<sub>DP</sub></i>, <i>V<sub>I</sub></i>, <i>V<sub>DT</sub></i>, <i>V<sub>LT</sub></i>, <i>V<sub>FA</sub></i>) be a vocabulary over <i>D</i>. An <span id="def_ic-interpretation"><i>IC-interpretation</i></span> <i>&#915;</i> = (<i>&#916;<sub>I</sub></i>, <i>&#916;<sub>D</sub></i>, <i>I</i>, <i>U</i>, <i>&#183;<sup>C</sup></i>, <i>&#183;<sup>OP</sup></i>, <i>&#183;<sup>DP</sup></i>, <i>&#183;<sup>I</sup></i>, <i>&#183;<sup>DT</sup></i>, <i>&#183;<sup>LT</sup></i>, <i>&#183;<sup>FA</sup></i>) for <i>D</i> and <i>V</i> is an 11-tuple with the following structure: </p>
<ul>
  <li><i>&#916;<sub>I</sub></i> is a nonempty set called the <span
	 id="def_object_domain"><i>object domain</i></span>. </li>
  <li><i>&#916;<sub>D</sub></i> is a nonempty set disjoint with
	 <i>&#916;<sub>I</sub></i> called the <span id="def_data_domain"><i>data
	 domain</i></span> such that <i>(DT)<sup>DT</sup></i> &#8838;
	 <i>&#916;<sub>D</sub></i> for each datatype <i>DT</i> &#8712;
	 <i>V<sub>DT</sub></i>. </li>
  <li><i>I</i> = (<i>&#916;<sub>I</sub></i>, <i>&#916;<sub>D</sub></i>, 
	 <i>&#183; <sup>C<sub>I</sub></sup></i>, <i>&#183;
	 <sup>OP<sub>I</sub></sup></i>, <i>&#183; <sup>DP<sub>I</sub></sup></i>, 
	 <i>&#183; <sup>I</sup></i>, <i>&#183; <sup>DT</sup></i>, <i>&#183;
	 <sup>LT</sup></i>, <i>&#183; <sup>FA</sup></i>) is an OWL interpretation
	 for <i>D</i> and <i>V</i>.</li>
  <li><i>U</i> = {<i>U<sub>1</sub></i>, <i>U<sub>2</sub></i>, ..., 
	 <i>U<sub>n</sub></i>} is a set where each <i>U<sub>j</sub></i> =
	 (<i>&#916;<sub>I<sub>j</sub></sub></i>, <i>&#916;<sub>D<sub>j</sub></sub></i>, <i>&#183;
	 <sup>C<sub>j</sub></sup></i>, <i>&#183;
	 <sup>OP<sub>j</sub></sup></i>, <i>&#183;
	 <sup>DP<sub>j</sub></sup></i>, <i>&#183;
	 <sup>I<sub>j</sub></sup></i>, <i>&#183; <sup>DT</sup></i>, 
	 <i>&#183; <sup>LT</sup></i>, <i>&#183; <sup>FA</sup></i>) for 1 &#8804; j &#8804;
	 n is an OWL interpretation for <i>D</i> and <i>V</i>.</li>
  <li><i>&#183; <sup>C</sup></i> is the <span
	 id="def_class_interpretation_function"><i>class interpretation
	 function</i></span> that assigns to each class <i>C &#8712;
	 V<sub>C</sub></i> a subset <i>(C)<sup>C</sup></i> &#8838;
	 <i>&#916;<sub>I</sub></i> such that 
	 <ul>
		<li><i>(owl:Thing)<sup>C</sup></i> = <i>&#916;<sub>I</sub></i>, </li>
		<li><i>(owl:Nothing)<sup>C</sup></i> = &#8709;, and </li>
		<li><i>(C)<sup>C</sup></i> = {<i>x<sup>I</sup></i> | <i>x &#8712;
		  V<sub>I</sub></i> and for each <i>U<sub>j</sub> &#8712; U</i> we have
		  that <i>x<sup>I<sub>U<sub>j</sub></sub></sup> &#8712; (C)<sup>C<sub>j</sub></sup></i> }. </li>
	 </ul>
  </li>
  <li><i>&#183; <sup>OP</sup></i> is the <span
	 id="def_object_property_interpretation_function"><i>object property
	 interpretation function</i></span> that assigns to each object property
	 <i>OP &#8712; V<sub>OP</sub></i> a subset <i>(OP)<sup>OP</sup></i> &#8838;
	 <i>&#916;<sub>I</sub></i> &#215; <i>&#916;<sub>I</sub></i> such that 
	 <ul>
		<li><i>(owl:topObjectProperty)<sup>OP</sup></i> =
		  <i>&#916;<sub>I</sub></i> &#215; <i>&#916;<sub>I</sub></i>, </li>
		<li><i>(owl:bottomObjectProperty)<sup>OP</sup></i> = &#8709;, and </li>
		<li><i>(OP)<sup>OP</sup></i> = {<i>(x<sup>I</sup>, y<sup>I</sup>)</i> |
		  <i>x &#8712; V<sub>I</sub></i>, y &#8712; V<sub>I</sub>, and for each
		  <i>U<sub>j</sub> &#8712; U</i> we have that
		  <i>(x<sup>I<sub>U<sub>j</sub></sub></sup>, 
		  y<sup>I<sub>U<sub>j</sub></sub></sup>) &#8712;
		  (OP)<sup>OP<sub>j</sub></sup></i> }.</li>
	 </ul>
  </li>
  <li><i>&#183; <sup>DP</sup></i> is the <span
	 id="def_data_property_interpretation_function"><i>data property
	 interpretation function</i></span> that assigns to each data property <i>DP
	 &#8712; V<sub>DP</sub></i> a subset <i>(DP)<sup>DP</sup></i> &#8838;
	 <i>&#916;<sub>I</sub></i> &#215; <i>&#916;<sub>D</sub></i> such that 
	 <ul>
		<li><i>(owl:topDataProperty)<sup>DP</sup></i> =
		  <i>&#916;<sub>I</sub></i> &#215; <i>&#916;<sub>D</sub></i>, </li>
		<li><i>(owl:bottomDataProperty)<sup>DP</sup></i> = &#8709;, and </li>
		<li><i>(DP)<sup>DP</sup></i> = {<i>(x<sup>I</sup>, lt<sup>LT</sup>)</i> |
		  <i>x &#8712; V<sub>I</sub>, lt &#8712; V<sub>LT</sub></i>, and for each
		  <i>U<sub>j</sub> &#8712; U</i> we have that
		  <i>(x<sup>I<sub>U<sub>j</sub></sub></sup>, lt<sup>LT</sup>) &#8712;
		  (DP)<sup>DP<sub>j</sub></sup></i> }.</li>
	 </ul>
  </li>
  <li><i>&#183; <sup>I</sup></i> is the <span
	 id="def_individual_interpretation_function"><i>individual interpretation
	 function</i></span> that assigns to each individual <i>a &#8712;
	 V<sub>I</sub></i> an element <i>(a)<sup>I</sup></i> &#8712;
	 <i>&#916;<sub>I</sub></i>.</li>
  <li><i>&#183; <sup>DT</sup></i> is the <span
	 id="def_datatype_interpretation_function"><i>datatype interpretation
	 function</i></span> that assigns to each datatype <i>DT &#8712;
	 V<sub>DT</sub></i> a subset <i>(DT)<sup>DT</sup></i> &#8838;
	 <i>&#916;<sub>D</sub></i> such that 
	 <ul>
		<li><i>&#183; <sup>DT</sup></i> is the same as in <i>D</i> for each
		  datatype <i>DT</i> &#8712; <i>N<sub>DT</sub></i>, and </li>
		<li><i>(rdfs:Literal)<sup>DT</sup></i> = <i>&#916;<sub>D</sub></i>. </li>
	 </ul>
  </li>
  <li><i>&#183; <sup>LT</sup></i> is the <span
	 id="def_literal_interpretation_function"><i>literal interpretation
	 function</i></span> that is defined as <i>(lt)<sup>LT</sup></i> = (
	 <i>LV</i>, <i>DT</i>)<i><sup>LS</sup></i> for each <i>lt</i> &#8712;
	 <i>V<sub>LT</sub></i>, where <i>LV</i> is the lexical form of <i>lt</i> and
	 <i>DT</i> is the datatype of <i>lt</i>. </li>
  <li><i>&#183; <sup>FA</sup></i> is the <span
	 id="def_facet_interpretation_function"><i>facet interpretation
	 function</i></span> that is defined as (<i>F</i>, <i>lt</i>
	)<i><sup>FA</sup></i> = (<i>F</i>, <i>(lt)<sup>LT</sup></i>
	)<i><sup>FS</sup></i> for each (<i>F</i>, <i>lt</i>) &#8712;
	 <i>V<sub>FA</sub></i>. </li>
</ul>

<p>The extensions
of <i>&#183; <sup>C</sup></i>, <i>&#183; <sup>OP</sup></i>,
and <i>&#183; <sup>DT</sup></i> to class expressions, object property
expressions, and data ranges respectively, are defined analogously to
OWL 2 [<cite><a href="#owl-2-direct-semantics">OWL 2 Direct Semantics</a></cite>]. For example, we
extend <i>&#183; <sup>C</sup></i> to the class
expression <i>ObjectIntersectionOf(CE<sub>1</sub> ...
CE<sub>n</sub>)</i> as <i>(CE<sub>1</sub>)<sup>C</sup></i> &#8745;
... &#8745;
<i>(CE<sub>n</sub>)<sup>C</sup></i>. However, we extend
<i>&#183; <sup>C</sup></i> to <i>ObjectComplementOf(CE)</i> as {<i>x<sup>I</sup></i>
| <i>x &#8712; V<sub>I</sub></i>} \ <i>(CE)<sup>C</sup></i>&#8212;that is, the
complement of a class expression is defined with respect to the set of <i>named
individuals</i> as opposed to the object domain. The complete extensions for
<i>&#183; <sup>C</sup></i>, <i>&#183; <sup>OP</sup></i>, and <i>&#183;
<sup>DT</sup></i> can be found in the <a
href="#appendix">Appendix</a>.</p>

<h3><a name="3.2" id="_3.2"></a>3.2 Axiom Satisfaction</h3>

<p>Satisfaction of an IC-interpretation <i>&#915;</i> with respect to
a given axiom is defined analogously to satisfaction of standard
intepretations defined in OWL 2
[<cite><a href="#owl-2-direct-semantics">OWL 2 Direct Semantics</a></cite>]. For example, <i>&#915;</i> satisfies
the axiom
<i>SubClassOf(CE<sub>1</sub> CE<sub>2</sub>)</i> if
<i>(CE<sub>1</sub>)<sup>C</sup></i> &#8838; <i>(CE<sub>2</sub>)<sup>C</sup></i>.
The complete definitions for axiom satisfaction can be found in the <a
href="#appendix">Appendix</a>.</p>

<h3><a name="3.3" id="_3.3"></a>3.3 Axiom IC-Satisfaction</h3>

<p>Let <i>D</i> = (<i>N<sub>DT</sub></i>, <i>N<sub>LS</sub></i>, <i>N<sub>FS</sub></i>, <i>&#183;<sup>DT</sup></i>, <i>&#183;<sup>LS</sup></i>, <i>&#183;<sup>FS</sup></i>)  be a datatype map and let <i>V</i> = (<i>V<sub>C</sub></i>, <i>V<sub>OP</sub></i>, <i>V<sub>DP</sub></i>, <i>V<sub>I</sub></i>, <i>V<sub>DT</sub></i>, <i>V<sub>LT</sub></i>, <i>V<sub>FA</sub></i>) be a vocabulary over <i>D</i>.</p>
<ul>
<li>Let <i>I</i> be an OWL interpretation for <i>D</i> and <i>V</i>. With <i>E<sub>I</sub></i> we denote the set of equality relations between named individuals satisfied by <i>I</i>. That is, <i>E<sub>I</sub></i> = { &#60;a, b&#62; | a &#8712; <i>V<sub>I</sub></i>, b &#8712; <i>V<sub>I</sub></i>, and <i>a<sup>I</sup></i> = <i>b<sup>I</sup></i> } where <i>&#183;<sup>I</sup></i> is the individual interpretation function of <i>I</i>.
</li>
<li>
Let <i>I</i> and <i>J</i> be OWL interpretations for <i>D</i> and <i>V</i>. We say that <i>I &#60;<sub>eq</sub> J</i> iff the following conditions are satisfied:
<ul>
<li>for every <i>C &#8712; V<sub>C</sub></i>, <i>I</i> satisfies <i>C(a)</i> iff <i>J</i> satisfies <i>C(a)</i></li>
<li>for every <i>R &#8712; V<sub>OP</sub></i>, <i>I</i> satisfies <i>R(a, b)</i> iff <i>J</i> satisfies <i>R(a, b)</i></li>
<li>for every <i>S &#8712; V<sub>DP</sub></i>, <i>I</i> satisfies <i>S(a, lt)</i> iff <i>J</i> satisfies <i>S(a, lt)</i></li>
<li><i>E<sub>I</sub></i> &#8834; <i>E<sub>J</sub></i></li>
</ul>
</li>
<li>
Let <i>O</i> be an OWL ontology. With <i>Mod(O)</i> we denote the set containing exactly all the models of <i>O</i> with respect to <i>D</i> and <i>V</i>. With <i>Mod<sub>ME</sub>(O)</i> we denote the set containing exactly all the models with minimal equality between named individuals. That is, <i>Mod<sub>ME</sub>(O)</i> = { <i>I</i> | <i>I</i> &#8712; <i>Mod(O)</i> and there is no <i>J</i> such that <i>J</i> &#8712; <i>Mod(O)</i> and <i>J &#60;<sub>eq</sub> I</i> }.
</li>
<li>
Let <i>O</i> be an OWL ontology and <i>&#945;</i> be an axiom. We say that <i>O</i> <em>IC-satisfies</em> <i>&#945;</i> iff for all <i>I</i> &#8712; <i>Mod<sub>ME</sub>(O)</i>, we have that the IC-interpretation <i>&#915;</i> = (<i>&#916;<sub>I</sub></i>, <i>&#916;<sub>D</sub></i>, <i>I</i>, <i>Mod<sub>ME</sub>(O)</i>, <i>&#183;<sup>C</sup></i>, <i>&#183;<sup>OP</sup></i>, <i>&#183;<sup>DP</sup></i>, <i>&#183;<sup>I</sup></i>, <i>&#183;<sup>DT</sup></i>, <i>&#183;<sup>LT</sup></i>, <i>&#183;<sup>FA</sup></i>) for <i>D</i> and <i>V</i> satisfies <i>&#945;</i>.
</li>
</ul>

<h3><a name="3.3" id="_3.4"></a>3.4 Inference Problem</h3>

<p>We are mainly interested in the following inference problem:</p>

<p><b>Ontology Validation</b>. Let <i>O</i> be an OWL ontology. We say
  that <i>O</i> is <em>Valid</em> iff for all axioms <i>&#945;</i> in
  the IC closure of <i>O</i>, it holds that <i>O</i> <em>IC-satisfies</em> <i>&#945;</i>.</p>

</div>

<div id="implementation">
<h2><a name="5" id="_5"></a>4. Implementation Remarks</h2>

<h3><a name="5.1" id="_5.1"></a>4.1 Implementing IC Syntax</h3>

<p>As discussed in <a href="#_2">Section 2</a>, we use
standard OWL syntax for ICs; store ICs in a separate document; and
define a new annotation property analogous to <span class="tt">owl:imports</span>,
that will associate a standard OWL ontology with a set of ICs defined for that
ontology.</p>

<p>The motivation for this design choice is to minimize the effects of      
ICs on existing tools. From the perspective of creation and maintenance,    
users can continue using existing ontology authoring toolsets. For example, 
one can use an OWL editor to create ICs and store them in a document. The   
ontology for which the constraints are written can be augmented with the IC 
import annotation easily, since this is a standard OWL annotation. With an  
OWL editor that allows users to open and edit multiple ontologies at the    
same time, the regular ontology and the IC ontology can be edited together. 
Several OWL editors provide the feature to move axioms between ontologies;  
hence, one can easily change the interpretation of an axiom just by moving  
it from the regular ontology to the IC ontology.</p>                        

<p>The only issue in using an existing OWL editor is as follows: when
a user opens a regular ontology that links to an IC ontology, the
editor will not open the IC ontology automatically. The user needs to
look at the ontology annotation and open the IC ontology
manually. However, this is not a serious issue since it is a
relatively simple extension for editors to recognize this
annotation. It is safe to assume that such extensions will be
available, especially if ICs start to be widely used.</p>

<p>Our approach has no impact on OWL existing reasoners that do not
support ICs: since the annotation property has no semantic effect,
they would not process that annotation. Therefore, there is no
additional work that needs to be done to hide the ICs in order to
avoid unintended inferences that would occur if they are inadvertently
interpreted as regular OWL axioms.</p>

<p>Note that our approach does not require an IC ontology to be 
identified as such. However, in case an ontology is to be exclusively interpreted as 
a set of ICs, one might use an ontology annotation to make this fact explicit. 
As usual, such annotations are for informational purposes only and have no effect on 
the semantics.</p>

<h3><a name="5.2" id="_5.2"></a>4.2 Implementing IC Semantics</h3>

<p>The IC semantics described in this document is strongly related to
the semantics presented in a paper
[<cite><a href="#TSBM10">TSBM10</a></cite>] giving a formal integrity
constraint semantics for the description logic SROIQ. Based on the
correspondence between SROIQ and OWL 2 semantics
[<cite><a href="#owl-2-direct-semantics">OWL 2 Direct
Semantics</a></cite>], the semantics we present here has been adapted
to OWL 2 and extended to support datatypes.</p>

<p>As discussed in the paper, there is a close relationship between IC
semantics and queries that have negation as failure (NAF)
operator. This is interesting from a practical point of view because a
validator for OWL IC can be implemented in a straightforward way: each
axiom in an IC ontology defined with respect to an OWL
ontology <i>O</i> can be effectively transformed into a SPARQL query
that can be later answered over <i>O</i> using the SPARQL entailment
regime that corresponds to <i>O</i>.</p>

<p>As a simple example of the translation, consider the IC presented
in <a href="#example-6">Example 6</a> above: </p>

<pre>Class: Supervisor 
   SubClassOf: supervises some Employee</pre>

<p>The translation of this IC to SPARQL would yield the following
  SPARQL query:</p>

<pre>
ASK WHERE { 
   ?x rdf:type :Supervisor . 
   OPTIONAL {
      ?x :supervises ?y . 
      ?y rdf:type :Employee . 
   }
   FILTER ( !bound( ?y ) )
}</pre>

<p>If the execution of the query over an ontology <i>O</i> returns
 <code>true</code>, we can conclude that the IC has been violated
by <i>O</i>; and, therefore, that <i>O</i> is <i>not</i> IC-valid with
respect to this constraint. Note that the query uses the
OPTIONAL/FILTER/!BOUND pattern to encode NAF. However, it is likely
that SPARQL 1.1 [<cite><a href="#SPARQL-1.1">SPARQL 1.1</a></cite>] will make
NAF more clearly visible syntatically, perhaps via <code>NOT
EXISTS</code> as in current drafts.</p>

<p>It has been shown that SPARQL
[<cite><a href="#SPARQL">SPARQL</a></cite>] has the same expressive
power as nonrecursive datalog programs with NAF
[<cite><a href="#AG08">AG08</a></cite>]. Therefore, it is possible to
translate OWL ICs to a set of rules that will be evaluated over an
ontology <i>O</i>. Such rules can be written using RIF Framework for
Logic Dialects [<cite><a href="#RIF-FLD">RIF-FLD</a></cite>] with
the <code>Naf</code> operator:</p>

<pre>
Forall ?x ?y (
    invalid() :- And (
        ?x[rdf:type -> :Supervisor]
        Naf And (
            ?x[:supervises -> ?y]
            ?y[rdf:type -> :Employee] )))
</pre>

<p>This rule uses the <code>Naf</code> operator for encoding NAF and 
defines an arbitrary RIF predicate <code>invalid</code> to detect the 
condition that an ontology <i>O</i> is invalid with respect to ICs. 
Implementations would be free to choose a different name for the 
predicate.</p> 

<p>Details of the translation are out of the scope here; interested
readers are referred to the formal semantics paper mentioned
previously
[<cite><a href="#TSBM10">TSBM10</a></cite>]. Translation-based IC
validation is one of many possibilities to implement IC validation and
has been mentioned here as an example. An IC validator conforming to
the IC semantics described here can also be implemented with different
approaches.</p>

</div>

<div id="acknowledgements">
<h2><a name="acknowledgments" id="acknowledgments"></a>Acknowledgements</h2>

<p>We wish to thank the following people for their assistance: Pavel        
Klinov, Michael Smith, Michael Grove, Jiao Tao, and Peter                   
Patel-Schneider. We thank members of the OWLED community, including         
the anonymous reviewers, who gave us very early feedback on using OWL       
as integrity constraints, including, most helpfully, use cases and          
requirements. We also acknowledge the support of NIST SBIR funding under    
the auspices of which this document was prepared.</p> </div>                

<div id="bib">
<h2><a id="references" name="references">References</a></h2>

<dl>
  <dt><a id="owl-2-direct-semantics" name="owl-2-direct-semantics">[OWL 2
  Direct Semantics]</a></dt>
	 <dd><cite><a href="http://www.w3.org/TR/owl2-direct-semantics/">OWL 2 Web
		Ontology Language: Direct Semantics</a></cite>. Boris Motik, Peter F.
		Patel-Schneider, Bernardo Cuenca Grau, eds. W3C Recommendation, 27
		October 2009, <a
		href="http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/">http://www.w3.org/TR/2009/REC-owl2-direct-semantics-20091027/</a>.
		Latest version available at <a
		href="http://www.w3.org/TR/owl2-direct-semantics/">http://www.w3.org/TR/owl2-direct-semantics/</a>.
	 </dd>
  <dt><a id="ref-owl-2-specification" name="ref-owl-2-specification">[OWL 2
  Specification]</a></dt>
	 <dd><cite><a href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/">OWL
		2 Web Ontology Language: Structural Specification and Functional-Style
		Syntax</a></cite>. Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, 
		eds. W3C Recommendation, 27 October 2009, <a
		href="http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/">http://www.w3.org/TR/2009/REC-owl2-syntax-20091027/</a>.
		Latest version available at <a
		href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>.</dd>
  <dt><a id="SPARQL" name="SPARQL">[SPARQL]</a></dt>
	 <dd><cite><a href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for RDF</a></cite>. Eric Prud'hommeaux and Andy Seaborne, eds. W3C Recommendation, 15 January 2008, 
<a href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">
http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/</a>. Latest version available as <a href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/</a>. 
</dd>
  <dt><a id="SPARQL-1.1" name="SPARQL1.1">[SPARQL-1.1]</a></dt>
    <dd><cite><a href="http://www.w3.org/TR/2010/WD-sparql11-query-20100126/">SPARQL Query Language 1.1</a></cite>. Steve Harris and Andy Seaborne, eds. W3C Working Draft, 26 January 2010, 
<a href="http://www.w3.org/TR/2010/WD-sparql11-query-20100126/">
http://www.w3.org/TR/2010/WD-sparql11-query-20100126/</a>. Latest version available as <a href="http://www.w3.org/TR/sparql11-query/">http://www.w3.org/TR/sparql11-query/</a>. 
</dd>
<dt><a id="TSBM10" name="TSBM10">[TSBM10]</a></dt>
	 <dd><cite>Integrity Constraints in OWL</cite>. Jiao Tao, 
		Evren Sirin, Jie Bao, Deborah L. McGuinness. In Proc. of the 24th
		Conference on Artificial Intelligence (AAAI 2010). Atlanta, USA. 2010.
	 </dd>
  <dt><a id="AG08" name="AG08">[AG08]</a></dt>
	 <dd><cite>The Expressive Power of SPARQL</cite>. Renzo
		Angles, Claudio Gutierrez. In Proc. of the 7th International Semantic Web
		Conference (ISWC 2008). Karlsruhe, Germany. 2008. </dd>
</dl>
</div>

<hr />

<div id="app">
<h2><a name="appendix" id="appendix"></a>Appendix A</h2>

<h3><a name="A.1" id="_A.1"></a>A.1 Extensions of Interpretation Functions
</h3>

<h4><a name="A.1.1" id="_A.1.1"></a>A.1.1 Class Expressions</h4>

<p>The class interpretation function <i>&#183;<sup>C</sup></i> is extended to
class expressions as shown in Table 1. For <i>S</i> a set, <i>#S</i> denotes
the number of elements in <i>S</i>. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 1.</span> Interpreting Class Expressions
  </caption>
  <tbody>
	 <tr>
		<th>Class Expression </th>
		<th>Interpretation <i>&#183;<sup>C</sup></i> </th>
	 </tr>
	 <tr>
		<td class="name">ObjectIntersectionOf(CE<sub>1</sub> ... CE<sub>n</sub>
		 ) </td>
		<td><i>(CE<sub>1</sub>)<sup>C</sup></i> &#8745; ... &#8745;
		  <i>(CE<sub>n</sub>)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">ObjectUnionOf(CE<sub>1</sub> ... CE<sub>n</sub>) </td>
		<td><i>(CE<sub>1</sub>)<sup>C</sup></i> &#8746; ... &#8746;
		  <i>(CE<sub>n</sub>)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">ObjectComplementOf(CE) </td>
		<td>{ <i>x<sup>I</sup></i>| <i>x &#8712; V<sub>I</sub></i> } \
		  <i>(CE)<sup>C</sup></i></td>
	 </tr>
	 <tr>
		<td class="name">ObjectOneOf(a<sub>1</sub> ... a<sub>n</sub>) </td>
		<td>{ <i>(a<sub>1</sub>)<sup>I</sup></i>, ..., 
		  <i>(a<sub>n</sub>)<sup>I</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectSomeValuesFrom(OPE CE) </td>
		<td>{ <i>x</i> | &#8707; <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> and <i>y</i> &#8712; <i>(CE)<sup>C</sup></i> }
		</td>
	 </tr>
	 <tr>
		<td class="name">ObjectAllValuesFrom(OPE CE) </td>
		<td>{ <i>x</i> | &#8704; <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> implies <i>y</i> &#8712;
		  <i>(CE)<sup>C</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectHasValue(OPE a) </td>
		<td>{ <i>x</i> | (<i>x</i>, <i>(a)<sup>I</sup></i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectHasSelf(OPE) </td>
		<td>{ <i>x</i> | (<i>x</i>, <i>x</i>) &#8712; <i>(OPE)<sup>OP</sup></i>
		  } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectMinCardinality(n OPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> } &#8805; n } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectMaxCardinality(n OPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> } &#8804; n } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectExactCardinality(n OPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> } = n } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectMinCardinality(n OPE CE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> and <i>y</i> &#8712; <i>(CE)<sup>C</sup></i> }
		  &#8805; n } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectMaxCardinality(n OPE CE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> and <i>y</i> &#8712; <i>(CE)<sup>C</sup></i> }
		  &#8804; n } </td>
	 </tr>
	 <tr>
		<td class="name">ObjectExactCardinality(n OPE CE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> and <i>y</i> &#8712; <i>(CE)<sup>C</sup></i> }
		  = n } </td>
	 </tr>
	 <tr>
		<td class="name">DataSomeValuesFrom(DPE<sub>1</sub> ... DPE<sub>n</sub>
		  DR) </td>
		<td>{ <i>x</i> | &#8707; <i>y<sub>1</sub></i>, ..., 
		  <i>y<sub>n</sub></i>: (<i>x</i>, <i>y<sub>k</sub></i>) &#8712;
		  <i>(DPE<sub>k</sub>)<sup>DP</sup></i> for each 1 &#8804; <i>k</i> &#8804;
		  <i>n</i> and (<i>y<sub>1</sub></i>, ..., <i>y<sub>n</sub></i>)
		  &#8712; <i>(DR)<sup>DT</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">DataAllValuesFrom(DPE<sub>1</sub> ... DPE<sub>n</sub>
		  DR) </td>
		<td>{ <i>x</i> | &#8704; <i>y<sub>1</sub></i>, ..., 
		  <i>y<sub>n</sub></i>: (<i>x</i>, <i>y<sub>k</sub></i>) &#8712;
		  <i>(DPE<sub>k</sub>)<sup>DP</sup></i> for each 1 &#8804; <i>k</i> &#8804;
		  <i>n</i> imply (<i>y<sub>1</sub></i>, ..., <i>y<sub>n</sub></i>)
		  &#8712; <i>(DR)<sup>DT</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">DataHasValue(DPE lt) </td>
		<td>{ <i>x</i> | (<i>x</i>, <i>(lt)<sup>LT</sup></i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">DataMinCardinality(n DPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i>} &#8805; n } </td>
	 </tr>
	 <tr>
		<td class="name">DataMaxCardinality(n DPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> } &#8804; n } </td>
	 </tr>
	 <tr>
		<td class="name">DataExactCardinality(n DPE) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> } = n } </td>
	 </tr>
	 <tr>
		<td class="name">DataMinCardinality(n DPE DR) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> and <i>y</i> &#8712; <i>(DR)<sup>DT</sup></i>
		  } &#8805; n } </td>
	 </tr>
	 <tr>
		<td class="name">DataMaxCardinality(n DPE DR) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> and <i>y</i> &#8712; <i>(DR)<sup>DT</sup></i>
		  } &#8804; n } </td>
	 </tr>
	 <tr>
		<td class="name">DataExactCardinality(n DPE DR) </td>
		<td>{ <i>x</i> | #{ <i>y</i> | (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> and <i>y</i> &#8712; <i>(DR)<sup>DT</sup></i>
		  } = n } </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.1.2" id="_A.1.2"></a>A.1.2 Object Property Expressions</h4>

<p>The object property interpretation function <i>&#183;<sup>OP</sup></i> is
extended to object property expressions as shown in Table 2. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 2.</span> Interpreting Object Property
  Expressions </caption>
  <tbody>
	 <tr>
		<th>Object Property Expression </th>
		<th>Interpretation <i>&#183;<sup>OP</sup></i> </th>
	 </tr>
	 <tr>
		<td class="name">ObjectInverseOf(OP) </td>
		<td>{ (<i>x</i>, <i>y</i>) | (<i>y</i>, <i>x</i>) &#8712;
		  <i>(OP)<sup>OP</sup></i> } </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.1.3" id="_A.1.3"></a>A.1.3 Data Ranges</h4>

<p>The datatype interpretation function <i>&#183;<sup>DT</sup></i> is extended
to data ranges as shown in Table 3. All datatypes in OWL 2 are unary, so each
datatype <i>DT</i> is interpreted as a unary relation over
<i>&#916;<sub>D</sub></i> &#8212; that is, as a set <i>(DT)<sup>DT</sup></i>
&#8838; <i>&#916;<sub>D</sub></i>. OWL 2 currently does not define data ranges
of arity more than one; however, by allowing for <i>n</i>-ary data ranges, the
syntax of OWL 2 provides a "hook" allowing implementations to introduce
extensions such as comparisons and arithmetic. An <i>n</i>-ary data range
<i>DR</i> is interpreted as an <i>n</i>-ary relation <i>(DR)<sup>DT</sup></i>
over <i>&#916;<sub>D</sub></i> &#8212; that is, as a set
<i>(DT)<sup>DT</sup></i> &#8838; <i>(&#916;<sub>D</sub>)<sup>n</sup></i>. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 3.</span> Interpreting Data Ranges
  </caption>
  <tbody>
	 <tr>
		<th>Data Range </th>
		<th>Interpretation <i>&#183;<sup>DT</sup></i> </th>
	 </tr>
	 <tr>
		<td class="name">DataIntersectionOf(DR<sub>1</sub> ... DR<sub>n</sub>)
		</td>
		<td><i>(DR<sub>1</sub>)<sup>DT</sup></i> &#8745; ... &#8745;
		  <i>(DR<sub>n</sub>)<sup>DT</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">DataUnionOf(DR<sub>1</sub> ... DR<sub>n</sub>) </td>
		<td><i>(DR<sub>1</sub>)<sup>DT</sup></i> &#8746; ... &#8746;
		  <i>(DR<sub>n</sub>)<sup>DT</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">DataComplementOf(DR) </td>
		<td><i>(&#916;<sub>D</sub>)<sup>n</sup></i> \ <i>(DR)<sup>DT</sup></i>
		  where <i>n</i> is the arity of <i>DR</i> </td>
	 </tr>
	 <tr>
		<td class="name">DataOneOf(lt<sub>1</sub> ... lt<sub>n</sub>) </td>
		<td>{ <i>(lt<sub>1</sub>)<sup>LT</sup></i>, ..., 
		  <i>(lt<sub>n</sub>)<sup>LT</sup></i> } </td>
	 </tr>
	 <tr>
		<td class="name">DatatypeRestriction(DT F<sub>1</sub> lt<sub>1</sub> ...
		  F<sub>n</sub> lt<sub>n</sub>) </td>
		<td><i>(DT)<sup>DT</sup></i> &#8745; (<i>F<sub>1</sub></i>, 
		  <i>lt<sub>1</sub></i>)<i><sup>FA</sup></i> &#8745; ... &#8745; (
		  <i>F<sub>n</sub></i>, <i>lt<sub>n</sub></i>)<i><sup>FA</sup></i> </td>
	 </tr>
  </tbody>
</table>
</div>

<h3><a name="A.2" id="_A.2"></a>A.2 Satisfaction of Axioms</h3>

<h4><a name="A.2.1" id="_A.2.1"></a>A.2.1 Class Expression Axioms</h4>

<p>Satisfaction of OWL 2 class expression axioms in <i>&#915;</i> with respect
to an ontology <i>O</i> is defined as shown in Table 4.</p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 4.</span> Satisfaction of Class
  Expression Axioms in an Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">SubClassOf(CE<sub>1</sub> CE<sub>2</sub>) </td>
		<td><i>(CE<sub>1</sub>)<sup>C</sup></i> &#8838;
		  <i>(CE<sub>2</sub>)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">EquivalentClasses(CE<sub>1</sub> ... CE<sub>n</sub>)
		</td>
		<td><i>(CE<sub>j</sub>)<sup>C</sup></i> =
		  <i>(CE<sub>k</sub>)<sup>C</sup></i> for each 1 &#8804; <i>j</i> &#8804;
		  <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> </td>
	 </tr>
	 <tr>
		<td class="name">DisjointClasses(CE<sub>1</sub> ... CE<sub>n</sub>)
		</td>
		<td><i>(CE<sub>j</sub>)<sup>C</sup></i> &#8745;
		  <i>(CE<sub>k</sub>)<sup>C</sup></i> = &#8709; for each 1 &#8804; <i>j</i>
		  &#8804; <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> such that <i>j</i>
		  &#8800; <i>k</i> </td>
	 </tr>
	 <tr>
		<td class="name">DisjointUnion(C CE<sub>1</sub> ... CE<sub>n</sub>)
		</td>
		<td><i>(C)<sup>C</sup></i> = <i>(CE<sub>1</sub>)<sup>C</sup></i> &#8746;
		  ... &#8746; <i>(CE<sub>n</sub>)<sup>C</sup></i> and<br />
		  <i>(CE<sub>j</sub>)<sup>C</sup></i> &#8745;
		  <i>(CE<sub>k</sub>)<sup>C</sup></i> = &#8709; for each 1 &#8804; <i>j</i>
		  &#8804; <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> such that <i>j</i>
		  &#8800; <i>k</i> </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.2.2" id="_A.2.2"></a>A.2.2 Object Property Expression
Axioms</h4>

<p>Satisfaction of OWL 2 object property expression axioms in <i>&#915;</i>
with respect to an ontology <i>O</i> is defined as shown in Table 5. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 5.</span> Satisfaction of Object
  Property Expression Axioms in an Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">SubObjectPropertyOf(OPE<sub>1</sub> OPE<sub>2</sub>)
		</td>
		<td><i>(OPE<sub>1</sub>)<sup>OP</sup></i> &#8838;
		  <i>(OPE<sub>2</sub>)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">SubObjectPropertyOf(ObjectPropertyChain(
		  OPE<sub>1</sub> ... OPE<sub>n</sub>) OPE) </td>
		<td>&#8704; <i>y<sub>0</sub></i>, ..., <i>y<sub>n</sub></i>: (
		  <i>y<sub>0</sub></i>, <i>y<sub>1</sub></i>) &#8712;
		  <i>(OPE<sub>1</sub>)<sup>OP</sup></i> and ... and (
		  <i>y<sub>n-1</sub></i>, <i>y<sub>n</sub></i>) &#8712;
		  <i>(OPE<sub>n</sub>)<sup>OP</sup></i> imply (<i>y<sub>0</sub></i>, 
		  <i>y<sub>n</sub></i>) &#8712; <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">EquivalentObjectProperties(OPE<sub>1</sub> ...
		  OPE<sub>n</sub>) </td>
		<td><i>(OPE<sub>j</sub>)<sup>OP</sup></i> =
		  <i>(OPE<sub>k</sub>)<sup>OP</sup></i> for each 1 &#8804; <i>j</i> &#8804;
		  <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> </td>
	 </tr>
	 <tr>
		<td class="name">DisjointObjectProperties(OPE<sub>1</sub> ...
		  OPE<sub>n</sub>) </td>
		<td><i>(OPE<sub>j</sub>)<sup>OP</sup></i> &#8745;
		  <i>(OPE<sub>k</sub>)<sup>OP</sup></i> = &#8709; for each 1 &#8804;
		  <i>j</i> &#8804; <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> such that
		  <i>j</i> &#8800; <i>k</i> </td>
	 </tr>
	 <tr>
		<td class="name">ObjectPropertyDomain(OPE CE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> implies <i>x</i> &#8712;
		  <i>(CE)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">ObjectPropertyRange(OPE CE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> implies <i>y</i> &#8712;
		  <i>(CE)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">InverseObjectProperties(OPE<sub>1</sub> OPE<sub>2</sub>
		 ) </td>
		<td><i>(OPE<sub>1</sub>)<sup>OP</sup></i> = { (<i>x</i>, <i>y</i>) | (
		  <i>y</i>, <i>x</i>) &#8712; <i>(OPE<sub>2</sub>)<sup>OP</sup></i> }
		</td>
	 </tr>
	 <tr>
		<td class="name">FunctionalObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>, <i>y<sub>1</sub></i>, <i>y<sub>2</sub></i>: (
		  <i>x</i>, <i>y<sub>1</sub></i>) &#8712; <i>(OPE)<sup>OP</sup></i> and
		  (<i>x</i>, <i>y<sub>2</sub></i>) &#8712; <i>(OPE)<sup>OP</sup></i>
		  imply <i>y<sub>1</sub></i> = <i>y<sub>2</sub></i> </td>
	 </tr>
	 <tr>
		<td class="name">InverseFunctionalObjectProperty(OPE) </td>
		<td>&#8704; <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, <i>y</i>: (
		  <i>x<sub>1</sub></i>, <i>y</i>) &#8712; <i>(OPE)<sup>OP</sup></i> and
		  (<i>x<sub>2</sub></i>, <i>y</i>) &#8712; <i>(OPE)<sup>OP</sup></i>
		  imply <i>x<sub>1</sub></i> = <i>x<sub>2</sub></i> </td>
	 </tr>
	 <tr>
		<td class="name">ReflexiveObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>: <i>x</i> &#8712; <i>&#916;<sub>I</sub></i>
		  implies (<i>x</i>, <i>x</i>) &#8712; <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">IrreflexiveObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>: <i>x</i> &#8712; <i>&#916;<sub>I</sub></i>
		  implies (<i>x</i>, <i>x</i>) &#8713; <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">SymmetricObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> implies (<i>y</i>, <i>x</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">AsymmetricObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> implies (<i>y</i>, <i>x</i>) &#8713;
		  <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">TransitiveObjectProperty(OPE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>, <i>z</i>: (<i>x</i>, <i>y</i>)
		  &#8712; <i>(OPE)<sup>OP</sup></i> and (<i>y</i>, <i>z</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> imply (<i>x</i>, <i>z</i>) &#8712;
		  <i>(OPE)<sup>OP</sup></i> </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.2.3" id="_A.2.3"></a>A.2.3 Data Property Expression Axioms </h4>

<p>Satisfaction of OWL 2 data property expression axioms in <i>I</i> with
respect to an ontology <i>O</i> is defined as shown in Table 6. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 6.</span> Satisfaction of Data Property
  Expression Axioms in an Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">SubDataPropertyOf(DPE<sub>1</sub> DPE<sub>2</sub>)
		</td>
		<td><i>(DPE<sub>1</sub>)<sup>DP</sup></i> &#8838;
		  <i>(DPE<sub>2</sub>)<sup>DP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">EquivalentDataProperties(DPE<sub>1</sub> ...
		  DPE<sub>n</sub>) </td>
		<td><i>(DPE<sub>j</sub>)<sup>DP</sup></i> =
		  <i>(DPE<sub>k</sub>)<sup>DP</sup></i> for each 1 &#8804; <i>j</i> &#8804;
		  <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> </td>
	 </tr>
	 <tr>
		<td class="name">DisjointDataProperties(DPE<sub>1</sub> ...
		  DPE<sub>n</sub>) </td>
		<td><i>(DPE<sub>j</sub>)<sup>DP</sup></i> &#8745;
		  <i>(DPE<sub>k</sub>)<sup>DP</sup></i> = &#8709; for each 1 &#8804;
		  <i>j</i> &#8804; <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> such that
		  <i>j</i> &#8800; <i>k</i> </td>
	 </tr>
	 <tr>
		<td class="name">DataPropertyDomain(DPE CE) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x</i>, <i>y</i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> implies <i>x</i> &#8712;
		  <i>(CE)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">DataPropertyRange(DPE DR) </td>
		<td>&#8704; <i>x</i>, <i>y</i>: (<i>x, </i>y) &#8712;
		  <i>(DPE)<sup>DP</sup></i> implies <i>y</i> &#8712;
		  <i>(DR)<sup>DT</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">FunctionalDataProperty(DPE) </td>
		<td>&#8704; <i>x</i>, <i>y<sub>1</sub></i>, <i>y<sub>2</sub></i>: (
		  <i>x</i>, <i>y<sub>1</sub></i>) &#8712; <i>(DPE)<sup>DP</sup></i> and
		  (<i>x</i>, <i>y<sub>2</sub></i>) &#8712; <i>(DPE)<sup>DP</sup></i>
		  imply <i>y<sub>1</sub></i> = <i>y<sub>2</sub></i> </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.2.4" id="_A.2.4"></a>A.2.4 Datatype Definitions </h4>

<p>Satisfaction of datatype definitions in <i>&#915;</i> with respect to an
ontology <i>O</i> is defined as shown in Table 7. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 7.</span> Satisfaction of Datatype
  Definitions in an Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">DatatypeDefinition(DT DR) </td>
		<td style="text-align: left"><i>(DT)<sup>DT</sup></i> =
		  <i>(DR)<sup>DT</sup></i> </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.2.5" id="_A.2.5"></a>A.2.5 Keys </h4>

<p>Satisfaction of keys in <i>&#915;</i> with respect to an ontology <i>O</i>
is defined as shown in Table 8. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 8.</span> Satisfaction of Keys in an
  Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">HasKey(CE (OPE<sub>1</sub> ... OPE<sub>m</sub>) (
		  DPE<sub>1</sub> ... DPE<sub>n</sub>)) </td>
		<td style="text-align: left">&#8704; <i>x</i>, <i>y</i>, 
		  <i>z<sub>1</sub></i>, ..., <i>z<sub>m</sub></i>, 
		  <i>w<sub>1</sub></i>, ..., <i>w<sub>n</sub></i>:<br />
		  if <i>x</i> &#8712; <i>(CE)<sup>C</sup></i> and
		  <i>ISNAMED<sub>O</sub>(x)</i> and<br />
		  <i>y</i> &#8712; <i>(CE)<sup>C</sup></i> and
		  <i>ISNAMED<sub>O</sub>(y)</i> and<br />
		  (<i>x</i>, <i>z<sub>i</sub></i>) &#8712;
		  <i>(OPE<sub>i</sub>)<sup>OP</sup></i> and (<i>y</i>, 
		  <i>z<sub>i</sub></i>) &#8712; <i>(OPE<sub>i</sub>)<sup>OP</sup></i> and
		  <i>ISNAMED<sub>O</sub>(z<sub>i</sub>)</i> for each 1 &#8804; <i>i</i> &#8804;
		  <i>m</i> and<br />
		  (<i>x</i>, <i>w<sub>j</sub></i>) &#8712;
		  <i>(DPE<sub>j</sub>)<sup>DP</sup></i> and (<i>y</i>, 
		  <i>w<sub>j</sub></i>) &#8712; <i>(DPE<sub>j</sub>)<sup>DP</sup></i> for
		  each 1 &#8804; <i>j</i> &#8804; <i>n</i><br />
		  then x = y </td>
	 </tr>
  </tbody>
</table>
</div>

<h4><a name="A.2.6" id="_A.2.6"></a>A.2.6 Assertions</h4>

<p>Satisfaction of OWL 2 assertions in <i>&#915;</i> with respect to an
ontology <i>O</i> is defined as shown in Table 9. </p>

<div class="center">

<table style="border: 1px solid black">
  <caption><span class="caption">Table 9.</span> Satisfaction of Assertions in
  an Interpretation </caption>
  <tbody>
	 <tr>
		<th>Axiom </th>
		<th>Condition </th>
	 </tr>
	 <tr>
		<td class="name">SameIndividual(a<sub>1</sub> ... a<sub>n</sub>) </td>
		<td><i>(a<sub>j</sub>)<sup>I</sup></i> =
		  <i>(a<sub>k</sub>)<sup>I</sup></i> for each 1 &#8804; <i>j</i> &#8804;
		  <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> </td>
	 </tr>
	 <tr>
		<td class="name">DifferentIndividuals(a<sub>1</sub> ... a<sub>n</sub>)
		</td>
		<td><i>(a<sub>j</sub>)<sup>I</sup></i> &#8800;
		  <i>(a<sub>k</sub>)<sup>I</sup></i> for each 1 &#8804; <i>j</i> &#8804;
		  <i>n</i> and each 1 &#8804; <i>k</i> &#8804; <i>n</i> such that <i>j</i> &#8800;
		  <i>k</i> </td>
	 </tr>
	 <tr>
		<td class="name">ClassAssertion(CE a) </td>
		<td><i>(a)<sup>I</sup></i> &#8712; <i>(CE)<sup>C</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">ObjectPropertyAssertion(OPE a<sub>1</sub> a<sub>2</sub>
		 ) </td>
		<td>(<i>(a<sub>1</sub>)<sup>I</sup></i>, 
		  <i>(a<sub>2</sub>)<sup>I</sup></i>) &#8712; <i>(OPE)<sup>OP</sup></i>
		</td>
	 </tr>
	 <tr>
		<td class="name">NegativeObjectPropertyAssertion(OPE a<sub>1</sub>
		  a<sub>2</sub>) </td>
		<td>(<i>(a<sub>1</sub>)<sup>I</sup></i>, 
		  <i>(a<sub>2</sub>)<sup>I</sup></i>) &#8713; <i>(OPE)<sup>OP</sup></i>
		</td>
	 </tr>
	 <tr>
		<td class="name">DataPropertyAssertion(DPE a lt) </td>
		<td>(<i>(a)<sup>I</sup></i>, <i>(lt)<sup>LT</sup></i>) &#8712;
		  <i>(DPE)<sup>DP</sup></i> </td>
	 </tr>
	 <tr>
		<td class="name">NegativeDataPropertyAssertion(DPE a lt) </td>
		<td>(<i>(a)<sup>I</sup></i>, <i>(lt)<sup>LT</sup></i>) &#8713;
		  <i>(DPE)<sup>DP</sup></i> </td>
	 </tr>
  </tbody>
</table>
</div>
</div>
<p class="copyright">Copyright &#169;
2010&ndash;2012 Clark &#38; Parsia, LLC. <a href="http://creativecommons.org/licenses/by-sa/3.0/">Some rights reserved.</a></p>
  
</body>
</html>
